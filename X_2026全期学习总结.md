# X_2026全期学习总结

### YouTube频道推荐+播放列表（逆向工程+系统安全+二进制安全）

#### RE//verse 2025

https://www.youtube.com/watch?v=yzcNJn_EOwg&list=PLBKkldXXZQhAW5QKjUQOUWaMAHAxDtgio

#### How To Use x64dbg for Beginners

https://www.youtube.com/watch?v=h3DphxQ6Ngg&list=PLPRkkVSNCrVVyXBRoZoIvWzKe6zes6RuF

#### IDA pro с нуля

https://www.youtube.com/watch?v=wEn9NuJ342c&list=PLZpTOzTNMmrMXlOz0cm1IsX9Y4Dq4SOp1

#### Let's Play/Hack - Pwn Adventure 3: Pwnie Island

https://www.youtube.com/watch?v=RDZnlcnmPUA&list=PLhixgUqwRTjzzBeFSHXrw9DnQtssdAwgG

#### قسمت صفر: معرفی دوره رایگان بررسی ساختار فایل های PE

https://www.youtube.com/watch?v=PCCM0jyxrcI&list=PLuoKBCfw80oJMdABycCM3E4BdYdYvYKqT

#### Cybersecurity

https://www.youtube.com/watch?v=s19BxFpoSd0&list=PLCW1jCrU4bCY4zWqGboxe96XbDFDYxjzz



## YouTuber

#### Low Level

https://www.youtube.com/@LowLevelTV

#### **John Hammond**

https://www.youtube.com/@_JohnHammond

#### **OnHexGroup**

https://www.youtube.com/@onhexgroup

#### **REverse Conference**

https://www.youtube.com/@REverseConf

#### **硅谷101播客**

https://www.youtube.com/@valley101podcast

#### **MIT OpenCourseWare**

https://www.youtube.com/@mitocw

#### **NahamSec**

https://www.youtube.com/@NahamSec

#### **NetworkChuck**

https://www.youtube.com/@NetworkChuck

#### **Tom Crown**

https://www.youtube.com/@TomCrown

#### **David Bombal**

https://www.youtube.com/@davidbombal

#### **LaurieWired**

https://www.youtube.com/@lauriewired

#### freeCodeCamp.org

https://www.youtube.com/@freecodecamp

#### **Zilox.** 

https://www.youtube.com/@z1l0x

#### The Cherno

https://www.youtube.com/@TheCherno

#### **he Bright Side of Mathematics**

https://www.youtube.com/@brightsideofmaths

#### Dave's Garage

http://youtube.com/@DavesGarage

#### **毕导THU**

https://www.youtube.com/@thu4878

#### **NullByte**

https://www.youtube.com/@NullByte0x

#### 









### Telegram频道（方向：逆向工程+系统安全+二进制安全）

We have been working for YOU for more than 7 years!!!
https://t.me/+9vdG4JOSgY8xMzdi

See also:
https://t.me/Cognitive_Security
https://t.me/CyberSecurityOSINT
https://t.me/Wireless_Cybersecurity
https://t.me/Sec0x01

https://t.me/IRCyberGuardians
RedTeaming TTPs
Bug Hunting
Web PenTest
Web Security
Binary Analysis
Exploit DEV
Malware DEV
Malware Analysis
BlueTeaming
Threat Hunting
SOC
CSIRT
FORENSICS
Open-Source Intelligence(OSINT)
Cybersec Tools

https://t.me/reverse_dungeon

https://t.me/zer0day1ab


Information must be flow free, money kill it

Copyright: hello@zerodaylab.us

Все материалы исключительно в образовательных целях. Ответственность за использо

We crack custom software
Price depends on complexity

Link: @CrackCloud
Private: @MalwarePrivateBot

For all questions @malwar
Cobalt Strikers: @CobaltStrikers
All Projects: malwarecorp.com

https://t.me/+NIrQOeX3-yIwMjRi

کانال محتوای دوره اسمبلی
لینک کانال مدرس دوره : 
https://t.me/itshield

دقت داشته باشین که شرط استفاده رایگان از دوره ارسال فاتحه و صلوات برای فرزندان مرحوم من است :
https://fatehe-online.ir/g/13486

https://t.me/itshieldassembly

黑洞资源笔记

https://t.me/piracy6

https://t.me/nonglidaji

https://t.me/mumachuanqi

https://t.me/xingda548

https://t.me/PythonCTF404

https://t.me/kalizhx_teak

DESCLAIMER

In this channell we will provide free red team resources

This channel is not responsible for any type illegal activities

note : download courses at your own risk... Do not blame us for any damage after downloading courses from this channel..

https://t.me/AllSecurityEngineeringCourses

https://t.me/P0x3k_1N73LL1G3NC3







### 站点收藏（方向：网络安全+综合）

[SecurityLab.ru](https://www.securitylab.ru/)

[Vickie Li's Security Blog](https://vickieli.dev/)

[Blog - Black Hills Information Security, Inc.](https://www.blackhillsinfosec.com/blog/)

[HackingHub](https://app.hackinghub.io/hubs/)

[Null Byte — The aspiring white-hat hacker/security awareness playground « Null Byte :: WonderHowTo](https://null-byte.wonderhowto.com/)

[Website Hacking Archives](https://www.hackingarticles.in/category/website-hacking/)

[z-library.sk](https://z-library.sk/)

[KSSD](https://www.pediy.com/kssd/index.html)

[安全圈微信搜索_订阅号及文章全面收录,一搜即达-AI赋能，深度分析](https://wechat.doonsec.com/#)

[李白你好VIP-网络安全情报攻防站](https://www.libaisec.com/)

[CN-SEC 中文网 | 聚合网络安全,存储安全技术文章,融合安全最新讯息](https://cn-sec.com/)

[Altenen Forum | Hacking, Onlyfans Leaks & Making Money](https://altenens.is/)

[0x00sec](https://0x00sec.org/)

[Checkmarx](https://checkmarx.com/resources/resource-type/videos/)

[Search for "reverse" returned 559 results - media.ccc.de](https://media.ccc.de/search/?q=reverse)

[CyberArsenal](https://cyberarsenal.org/)

[TurkHackTeam](https://www.turkhackteam.org/)

[Noirth.com](https://noirth.com/)

[raxpro | Cracking, Spamming, Carding, Hacking & Leaks Forum • C](https://craxpro.io/)

[Craxpro | Cracking, Spamming, Carding, Hacking & Leaks Forum](https://craxpro.io/)

[FuzzySecurity | Home](https://fuzzysecurity.com/)

[Kitploit – Maintenance in Progress](https://kitploit.com/)





## 书籍推荐：（逆向工程+系统安全+二进制安全）



1 《逆向工程权威指南》
2 《加密与解密》
3  《逆向工程核心原理》 
4  《我的第一本算法书》
5  《Linux内核设计与实现》
6  《深入理解Linux内核》
7  《ctf-all-in-one》
8 《OllyDbg 中文帮助手册》
9 《有趣的二进制》
10 《Ghidra权威指南》
11  《IDApro权威指南》
12 《0day安全：软件漏洞和分析技术》
13  《二进制安全学习笔记》
14  《x86汇编语言》
15  《C语言原理》
16  《**编译原理**》
17   《**现代编译原理：C语言描述**》**《编译原理与实践》****《编译器设计》**









****









### 书籍笔记（逆向工程+二进制安全+算法+系统内核）

CPU是执行程序机器码的硬件单元。简要地说，其相关概念主要有
以下几项。
指令码：CPU受理的底层命令。典型的底层命令有：将数据在寄
存器间转移、操作内存、计算运算等指令。每类CPU都有自己的指令集
架构（Instruction Set Architecture，ISA）。
机器码：发送给CPU的程序代码。一条指令通常被封装为若干字
节。
汇编语言：为了让程序员少长白头发而创造出来的、易读易记的
代码，它有很多类似宏的扩展功能。
CPU寄存器：每种CPU都有其固定的通用寄存器（GPR）。x86 CPU
里一般有8个GPR，x64里往往有16个GPR，而ARM里则通常有16个GPR。
您可以认为CPU寄存器是一种存储单元，它能够无差别地存储所有类型
的临时变量。假如您使用一种高级的编程语言，且仅会使用到8个32位
变量，那么光CPU自带的寄存器就能完成不少任务了！
那么，机器码和编程语言（PL）的区别在哪里？CPU可不像人类那
样，能够理解C/C++、Java、Python这类较为贴近人类语言的高级编程
语言。CPU更适合接近硬件底层的具体指令。在不久的将来，或许会出
现直接执行高级编程语言的CPU，不过那种尚未问世的科幻CPU必定比
现在的CPU复杂。人脑和计算机各有所长，如果人类直接使用贴近硬件
底层的汇编语言编写程序，其难度也很高——因为那样很容易出现大
量的人为失误。可见，我们需要用一种程序把高级的编程语言转换为
CPU能受理的底层汇编语言，而这种程序就是人们常说的编译
器/Compiler



栈是计算机科学里最重要且最基础的数据结构之一。[1]
从技术上说，栈就是CPU寄存器里的某个指针所指向的一片内存区域。这
里所说的“某个指针”通常位于x86/x64平台的ESP寄存器/RSP寄存器，以及
ARM平台的SP寄存器。
操作栈的最常见的指令是PUSH和POP，在x86和ARM Thumb模式的指令集里
都有这两条指令。PUSH指令会对ESP/RSP/SP寄存器的值进行减法运算，使之
减去4（32位）或8（64位），然后将操作数写到上述寄存器里的指针所指向
的内存中。
POP指令是PUSH指令的逆操作：它先从栈指针（Stack Pointer，上面三
个寄存器之一）指向的内存中读取数据，用以备用（通常是写到其他寄存器
里），然后再将栈指针的数值加上4或8。
在分配栈的空间之后，栈指针，即Stack Pointer所指向的地址是栈的底
部。PUSH将减少栈指针的数值，而POP会增加它的数值。栈的“底”实际上使
用的是整个栈的最低地址，即是整个栈的启始内存地址。虽然听起来很奇
怪，但是实际上确实如此。
虽然x86/x64的栈已经很难理解了，但是ARM的栈却更为复杂。ARM的栈分
为递增栈和递减栈。递减栈（descending stack）的首地址是栈的最高地
址，栈向低地址增长，栈指针的值随栈的增长而减少，如STMFD/LDMFD、
STMED/LDMED等指令都是递减栈的操作指令。而ARM的递增栈（ascending
stack）的首地址则占用栈的最低地址，栈向高地址增长，栈指针的值随栈的
增长而增加，如STMFA/LMDFA、STMEA/LDMEA等指令都是递增栈的操作指令。

void型函数的返回值
主函数main()的数据类型通常是void而不是int，程序如何处理返
回值呢？
调用main()函数的有关代码大体会是这样的：
push envp
push argv
push argc
call main
push eax
call exit
将其转换为源代码，也就是：
exit(main(argc,argv,envp));
如果声明main()的数据类型是void，则main()函数不会明确返回
任何值（没有return指令）。不过在main()函数退出时，EAX寄存器还
会存有数据，EAX寄存器保存的数据会被传递给exit()函数、成为后者
的输入参数。通常EAX寄存器的值会是被调用方函数残留的确定数据，
所以void类型函数的返回值、也就是主函数退出代码往往属于伪随机
数（pseudorandom）。

函数返回值不被调用的情况
printf() 函数的返回值为打印的字符的总数，但是很少有程序会
使用这个返回值。实际上，确实有调用运算函数、却不使用运算结果
的程序：
int f()
{
// skip first 3 random values
rand();
rand();
rand();
// and use 4th
return rand();
};
上述四个rand()函数都会把运算结果存储到EAX寄存器里。但是前
三个rand()函数留在EAX寄存器的运算结果都被抛弃了。
9.3 返回值为结构体型数据
我们继续讨论使用EAX寄存器存储函数返回值的案例。函数只能够
使用EAX这1个寄存器回传返回值。因为这种局限，过去的C编译器无法
编译返回值超过EAX容量（一般来说，就是int型数据）的函数。那个
时候，如果要让返回多个返回值，那么只能用函数返回一个值、再通
过指针传递其余的返回值。现在的C编译器已经没有这种短板了，
return指令甚至可以返回结构体型的数据，只是时下很少有人会这么
做。如果函数的返回值是大型结构的数据，那么应由调用方函数
（caller）负责分配空间，给结构体分配指针，再把指针作为第一个
参数传递给被调用方函数。现在的编译器已经能够替程序员自动完成
这种复杂的操作了，其处理方式相当于上述几个步骤，只是编译器隐
藏了有关操作。



指针
指针通常用来帮助函数处理返回值（请参阅第7章的范例）。当函数需要
返回多个值时，它通常都是通过指针传递返回值的。

数据类型
16位（8086/80286）、32位（80386等）和64位系统常用的数据类
型有：
byte（字节）：8位数据。声明字节型数组和变量的汇编伪指令是
DB。计算机使用寄存器的低8位空间存储字节型数据。也就是说，字
节型数据通常存储在（寄存器助记符）AL/BL/CL/DL/AH/BH/
CH/DH/SIL/DIL/R*L里。
word（字）：16位数据。声明字型数组和变量的汇编伪指令是
DW。计算机使用寄存器的16位空间存储word型数据。也就是说，字
型数据通常存储在（寄存器助记符）AX/BX/CX/DX/SI/DI/R*W里。
dword/double word：32位数据。声明DWord型数组和变量的汇编
伪指令是DD。x86 CPU的标准寄存器及x64 CPU寄存器的32位空间都
可存储DWord型数据。16位应用程序则用寄存器对来存储DWord型数
据。
qword/quad word：64位数据。声明QWord型数组和变量的汇编伪
指令是DQ。32位系统使用一对寄存器来存储QWord型数据。
tbyte（10字节型）：80位，即10字节数据。符合IEEE 754标准的
FPU寄存器都采用这种类型的数据。

通用寄存器
x86-64的CPU可以直接调用多数通用寄存器的8位（byte）和16位
（word）存储空间。通用寄存器有前向兼容的特性（可兼容最早的
8080CPU）。早期的8位CPU（例如8080）可以用一对8位寄存器存储一
个16位数据。如此一来，面向早期8080平台的程序就可以照常访问16
位寄存器的低8位空间、高8位空间，还能够把这两个寄存器的数据当
作一个整体的16位寄存器使用。x86平台的这种前向兼容的特性，或许
是为了方便人们在不同平台上移植程序。而采用RISC精简指令集的
CPU则通常没有这种特性。
此外，x86-64 CPU上有R开头的寄存器，而80386以后的CPU都有E
开头的寄存器。可见，R-寄存器属于64位寄存器，而E-寄存器属于32
位寄存器。
x86-64 CPU还比x86 CPU多了8个通用寄存器，即R8～R15寄存器。
在Intel官方手册中，这些寄存器的低8位空间（byte）的助记符带
有“L”后缀（例如R8L），而IDA程序则给它们加上了后缀“B”
（例如R8B）。
A.2.1 RAX/EAX/AX/AL

段地址寄存器CS/DS/ES/SS/FS/GS
CS/DS/SS/ES分别代表Code Segment代码段寄存器、Data Segment
数据段寄存器、Stack Segment堆栈段寄存器和Extra Segment附加段寄存
器。
在Win32系统里，FS附加段寄存器（Extra Segment Register）承担
TLS（线程本地存储/Thread Local Storage）的角色；而在Linux系统
里，GS（另一个附加段寄存器）承担这个角色。早期，这两个寄存器
用于实现段式寻址；而现在，它们用于提供更为快速的TLS和TIB（线
程信息块/ThreadInformationBlock）功能。有关段地址寄存器的详细介
绍，请参见本书第94章。

指令前缀
LOCK：数据总线封锁前缀。在执行LOCK作前缀的汇编指令
时，它可起到独占数据总线的作用。简单地说，在执行这种指令时，
多处理器的其他CPU都将停下来、等该指令执行结束。这种指令常见
于各种关键系统、（硬件）信号量和互斥锁。
禁止协处理器修改数据总线上的数据，起到独占总线的作用。该
指令的执行不影响任何标志位。它常作为ADD、AND、BTR、BTS、
CMPXCHG、OR、XADD、XOR指令的前缀。本书的第68章第4节详
细介绍了这种指令。
REP：与MOVSx和STOSx指令结合使用，以循环的方式进行数据
复制及数据存储。在执行REP指令时，CX/ECX/RCX寄存器里存储的
值将作为隐含的循环计数器。有关MOVSx和STOSx指令的详细说明，
请参见附录A.6.2。
REP指令属于DF敏感指令。DF标识位决定了它的操作方向。
REPE/REPNE：（又称为REPZ/REPNZ）与CMPSx和SCASx指令
结合使用，以循环的方式进行数值比较。在执行这种指令时，
CX/ECX/RCX 寄存器里存储的值将作为隐含的循环计数器。当ZF标
识位为0（REPE），或ZF标识位为1（REPNE）时，它将终止循环过
程。
有关CMPSx和SCASx的详细描述，请参见附录A.6.2和A.6.3。
REPE/REPNE指令属于DF敏感指令。DF标识位决定了它的操作
方向。
A.6.2 常见指令
ADC（进位加法运算）：在进行加法运算时，会把 CF 标识位代
表的进位加入和中。它常见于较大数值的加法运算。例如，在32位系
统进行64位数值的加法运算时，会组合使用ADD和ADC指令，如下所
示：
; 64位值的运算：val2= val1 + val2.
; .lo 代表低32位，.hi代表高32位。
ADD val1.lo, val2.lo
ADC val1.hi,val2.hi；会使用上一条指令设置的CF
本书的第24章有更为详细的使用案例。
ADD：加法运算指令。
AND：逻辑“与”运算指令。
CALL：调用其他函数。相当于“PUSH（CALL之后的返回地
址）；JMP label”。
CMP：比较数值、设置标识位。虽然它的运算过程确是减法运
算，但是SUB指令保存运算结果（差）、而CMP指令不保存运算结
果。
DEC：递减运算。它不影响CF标识位。
IMUL：有符号数的乘法运算指令。
INC：递增运算。它不影响CF标识位。
JCXZ，JECXZ，JRCXZ（M）：当CX/ECX/RCX=0时跳转。
JMP：跳转到指定地址。相应的opcode中含有转移偏移量（jump
offset）。
Jcc：条件转移指令。cc是condition code的缩写。
JAE即JNC：（unsigned）在大于或等于的情况下进行跳转；转移
条件是CF=0。
JA即JNBE：（unsigned）在大于的情况下进行跳转；转移条件是
CF=0且ZF=0。
JBE：（unsigned）在小于或等于的条件下进行跳转；转移条件是
CF=1或ZF=1。
JB即JC：（unsigned）在小于的情况下进行跳转；转移条件是
CF=1
JC即JB：在小于的情况下进行跳转；转移条件是CF=1。
JE即JZ：在相等的情况下进行跳转；转移条件是ZF=1。
JGE：（signed）在大于或等于的情况下进行跳转；转移条件是
SF=OF。
JG：（signed）在大于的情况下进行跳转；转移条件是ZF=0且
SF=OF。
JLE：（signed）在小于或等于的情况下进行跳转；转移条件是
ZF=1或SF≠OF。
JL：（signed）在小于的条件下进行跳转；转移条件是SF≠OF。
JNAE即JC：（unsigned）在小于（不大于且不相等）的情况下进
行跳转；转移条件是CF=1。
JNA：（unsigned）在不大于的情况下进行跳转；转移条件是
CF=1或ZF=1。
JNBE：（unsigned）在大于的情况下进行转移；转移条件是CF=0
且ZF=0。
JNB即JNC：（unsigned）在不小于的情况下进行跳转；转移条件
是CF=0。
JNC即JAE：等同于JNB；转移条件是CF=0。
JNE即JNZ：在不相等的情况下进行跳转；转移条件是ZF=0。
JNGE：（signed）在不大于且不等于的情况下进行跳转；转移条
件是SF≠OF。
JNG：（signed）在不大于的情况下进行跳转；转移条件是ZF=1
或SF≠OF。
JNLE：（signed）在不大于且不相等的情况下进行跳转；转移条
件是ZF=0且SF=OF。
JNL：（signed）在不小于的情况下进行跳转；转移条件是
SF=OF。
JNO：在不溢出的情况下进行跳转；转移条件是OF=0。
JNS：在SF标识位为0的情况下进行跳转。
JNZ即JNE：在不大于且不等于的情况下进行跳转；转移条件是
ZF=0
JO：在溢出的情况下进行跳转；转移条件是OF=1。
JPO：在PF标识位为零的情况下进行跳转。
JP即JPE：在PF标识位为1的情况下进行跳转。
JS：在SF标识位为1的情况下进行跳转。
JZ即JE：在操作数相等的情况下进行跳转；转移条件是ZF=1。
LAHF：标识位读取指令。它把标识位复制到AH寄存器。数权关
系如下表所示。

