# X_2025全期学习总结

### Burpsuite AI MCP（插件商店）

https://github.com/portswigger/mcp-server

将Burpsuite安装MCP插件，接入LLM大模型，使其通过AI自动进行渗透测试和分析请求和响应包

### IDApro AI MCP 

https://github.com/mrexodia/ida-pro-mcp
让IDApro通过MCP接入LLM大模型，使其通过AI进行逆向分析



## CTF靶场练习和过程（B站视频）

#### 【OSCP考试】HackTheBox 300小时打靶教程 | 红队渗透测试 | 附字幕版

https://www.bilibili.com/video/BV1194y1S7sm/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac

#### TryHackMe 渗透测试靶场实战系列 | 120小时&附字幕版

https://www.bilibili.com/video/BV1Sg4y1j7Uu/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac

#### ★★★★★「红队笔记」靶机精讲

https://www.bilibili.com/video/BV1fKCzYWEYP/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac


## PWN二进制安全教程（B站视频）

#### 你想有多PWN

https://www.bilibili.com/video/BV15S4y1X73M/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac	

#### PWN全集，从入门到精通，最通俗易懂的CTF

https://www.bilibili.com/video/BV1Uv411j7fr/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac

#### XMCVE 2020 CTF Pwn入门课程

https://www.bilibili.com/video/BV1854y1y7Ro/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac

#### NTUSTISC - Pwn

https://www.bilibili.com/video/BV1UW4y157hJ/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac

#### B站CTF系列PWN全集，从入门到精通

https://www.bilibili.com/video/BV1k9UxYkERf/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac



## 软件逆向工程（B站视频）

#### x64dbg反汇编技术 - 小白基础入门

https://www.bilibili.com/video/BV1uU4y1f7HK/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac

#### 编译器、解释器和正式语言

https://www.bilibili.com/video/BV1xJUCYfEiT/?spm_id_from=333.999.0.0&vd_source=22271520dc2730df6e26cecebb20baac





# 逆向工程Reverse

#### CTF-All-In-One （汇编基础+PWN+Reverse）

https://firmianay.gitbook.io/ctf-all-in-one/1_basic/1.5_reverse_basic/1.5.2_assembly

#### CTF Wiki：Reverse

https://ctf-wiki.org/reverse/tools/static-analyze/ida/

#### Reverse Engineering 101

https://malwareunicorn.org/workshops/re101.html#0

#### Reverse Engineering 102

https://malwareunicorn.org/workshops/re102.html#5

#### 《100个gdb小技巧》

https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html

#### docs.pwntools

https://docs.pwntools.com/en/latest/

#### Dev？Pwn

https://dev.to/search?utf8=%E2%9C%93&q=pwn

#### Reverse BLOG

https://halb.it/articles/

#### Azeria-实验室

https://azeria-labs.com/

#### malwareunicorn 

https://malwareunicorn.org/#/workshops

#### Reverse4you逆向工程

https://forum.reverse4you.org/

#### pwndbg.re

[Documentation](https://pwndbg.re/stable/)





# 杂

#### hacktricks.wiki 知识库

https://book.hacktricks.wiki/en/index.html

#### 二进制期刊

https://phrack.org/issues/59/14#article

#### 自学路线

https://roadmap.sh/roadmaps

#### 逆向挑战Reverse.Kr

http://www.reversing.kr/index.php?ckattempt=1

#### Manim 数学可视化

https://www.manim.community/

#### 攻击性人工智能AI汇编

https://jiep.github.io/offensive-ai-compilation/

#### AI漏洞poc生成

https://cloud.projectdiscovery.io/

#### 反编译在线工具

https://dogbolt.org/
https://www.decompiler.com/

#### 在线16进制工具

https://hexed.it/
https://hex.dance/

#### C，C++ 反编译 汇编工具

https://godbolt.org/

#### 二进制漏洞？？

https://liber3.eth.limo/#/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E

#### 红队？

https://0x1.gitlab.io/pentesting/Red-Teaming-Toolkit/



# 数学，物理，计算科学类

### 数学：

https://probability.visualized.fun/

文献下载arXiv.org
[arXiv.org e-Print archive](https://arxiv.org/)

### 量子物理：

Ten Minute Physics

https://matthias-research.github.io/pages/tenMinutePhysics/index.html	

quantamagazine

https://www.quantamagazine.org/

naked-science.ru
https://naked-science.ru/



### 工程

https://animagraffs.com/



### 计算机基础，计算机科学：

AI文献检索

https://www.aminer.cn/



### 软件逆向工程科学：

[دوره رایگان مهندسی معکوس نرم افزار](https://onhexgroup.ir/software-reverse-engineering-tutorials/?utm_source=chatgpt.com)

[[pwn基础\]PWN二进制漏洞学习指南 - VxerLee昵称已被使用 - 博客园](https://www.cnblogs.com/VxerLee/p/15424926.html)

[Null Byte — The aspiring white-hat hacker/security awareness playground « Null Byte :: WonderHowTo](https://null-byte.wonderhowto.com/)

https://exploitation.ashemery.com/

https://pwn.college/





# 大神博客，相互学习

Pwn3rzshttps://github.com/Pwn3rzs

https://cyberarsenal.org/


0-d3yhttps://github.com/0-d3y
1N3https://github.com/1N3
jm33-m0https://github.com/jm33-m0

PwnPeterhttps://github.com/PwnPeter

securitycipherhttps://github.com/securitycipher

blacklanternsecurityhttps://github.com/blacklanternsecurity

https://blog.betamao.me/category/reverse.html



# Telegram 高质量学习资料分享

#### 深网网络安全资料

https://v01dnl.blogspot.com/

漏洞：
https://exploit-notes.hdks.org/

地下网络资源：

https://vx-underground.org/



https://www.dr-farfar.com/

hide01.ir

https://hide01.ir/





## IDA Python

## 常用插件

- [IDA FLIRT Signature Database](https://github.com/push0ebp/sig-database) — 用于识别静态编译的可执行文件中的库函数
- [Find Crypt](https://github.com/polymorf/findcrypt-yara) — 寻找常用加密算法中的常数（需要安装 [yara-python](https://github.com/VirusTotal/yara-python)）
- [IDA signsrch](https://github.com/nihilus/IDA_Signsrch) — 寻找二进制文件所使用的加密、压缩算法
- [Ponce](https://github.com/illera88/Ponce) — 污点分析和符号化执行工具
- [snowman decompiler](https://github.com/yegord/snowman/tree/v0.1.0) — C/C++反汇编插件（F3 进行反汇编）
- [CodeXplorer](https://github.com/REhints/HexRaysCodeXplorer) — 自动类型重建以及对象浏览（C++）（jump to disasm)
- [IDA Ref](https://github.com/nologic/idaref) — 汇编指令注释（支持arm，x86，mips）
- [auto re](https://github.com/a1ext/auto_re) — 函数自动重命名
- [nao](https://github.com/tkmru/nao) — dead code 清除
- [HexRaysPyTools](https://github.com/igogo-x86/HexRaysPyTools) — 类/结构体创建和虚函数表检测
- [DIE](https://github.com/ynvb/DIE) — 动态调试增强工具，保存函数调用上下文信息
- [sk3wldbg](https://github.com/cseagle/sk3wldbg) — IDA 动态调试器，支持多平台
- [idaemu](https://github.com/36hours/idaemu) — 模拟代码执行（支持X86、ARM平台）
- [Diaphora](https://github.com/joxeankoret/diaphora) — 程序差异比较
- [Keypatch](https://github.com/keystone-engine/keypatch) — 基于 Keystone 的 Patch 二进制文件插件
- [FRIEND](https://github.com/alexhude/FRIEND) — 哪里不会点哪里，提升汇编格式的可读性、提供指令、寄存器的文档等
- [SimplifyGraph](https://github.com/fireeye/SimplifyGraph) — 简化复杂的函数流程图
- [bincat](https://github.com/airbus-seclab/bincat) — 静态二进制代码分析工具包，2017 Hex-Rays 插件第一名
- [golang_loader_assist](https://github.com/strazzere/golang_loader_assist) — Golang编译的二进制文件分析助手
- [BinDiff](https://www.zynamics.com/bindiff.html)

## 常用脚本

### 内存 dump 脚本

调试程序时偶尔会需要 dump 内存，但 IDA Pro 没有直接提供此功能，可以通过脚本来实现。

```
import idaapidata = idaapi.dbg_read_memory(start_address, data_length)fp = open('path/to/dump', 'wb')fp.write(data)fp.close()
```

## 技巧

### 堆栈不平衡

某些函数在使用 f5 进行反编译时，会提示错误 “sp-analysis failed”，导致无法正确反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp 发生错误。

解决办法步骤如下：

1. 用 Option->General->Disassembly, 将选项 Stack pointer 打钩
2. 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡
3. 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret xx 是否匹配
4. 注意观察 jmp 指令前后的堆栈是否有变化
5. 有时用 Edit->Functions->Edit function…,然后点击 OK 刷一下函数定义





## Radare2 在命令行下有一些小工具可供使用：

- radare2：十六进制编辑器和调试器的核心，通常通过它进入交互式界面。
- rabin2：从可执行二进制文件中提取信息。
- rasm2：汇编和反汇编。
- rahash2：基于块的哈希工具。
- radiff2：二进制文件或代码差异比对。
- rafind2：查找字节模式。
- ragg2：r_egg 的前端，将高级语言编写的简单程序编译成x86、x86-64和ARM的二进制文件。
- rarun2：用于在不同环境中运行程序。
- rax2：数据格式转换。



### radare2/r2

```
$ r2 -hUsage: r2 [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]          [-s addr] [-B baddr] [-M maddr] [-c cmd] [-e k=v] file|pid|-|--|= --           run radare2 without opening any file -            same as 'r2 malloc://512' =            read file from stdin (use -i and -c to run cmds) -=           perform !=! command to run all commands remotely -0           print \x00 after init and every command -a [arch]    set asm.arch -A           run 'aaa' command to analyze all referenced code -b [bits]    set asm.bits -B [baddr]   set base address for PIE binaries -c 'cmd..'   execute radare command -C           file is host:port (alias for -c+=http://%s/cmd/) -d           debug the executable 'file' or running process 'pid' -D [backend] enable debug mode (e cfg.debug=true) -e k=v       evaluate config var -f           block size = file size -F [binplug] force to use that rbin plugin -h, -hh      show help message, -hh for long -H ([var])   display variable -i [file]    run script file -I [file]    run script file before the file is opened -k [k=v]     perform sdb query into core->sdb -l [lib]     load plugin file -L           list supported IO plugins -m [addr]    map file at given address (loadaddr) -M           do not demangle symbol names -n, -nn      do not load RBin info (-nn only load bin structures) -N           do not load user settings and scripts -o [OS/kern] set asm.os (linux, macos, w32, netbsd, ...) -q           quiet mode (no prompt) and quit after -i -p [prj]     use project, list if no arg, load if no file -P [file]    apply rapatch file and quit -R [rarun2]  specify rarun2 profile to load (same as -e dbg.profile=X) -s [addr]    initial seek -S           start r2 in sandbox mode -t           load rabin2 info in thread -u           set bin.filter=false to get raw sym/sec/cls names -v, -V       show radare2 version (-V show lib versions) -w           open file in write mode -X [rr2rule] specify custom rarun2 directive -z, -zz      do not load strings or load them even in raw
```

参数很多，这里最重要是 `file`。如果你想 attach 到一个进程上，则使用 `pid`。常用参数如下：

- `-A`：相当于在交互界面输入了 `aaa`。
- `-c`：运行 radare 命令。（`r2 -A -q -c 'iI~pic' file`）
- `-d`：调试二进制文件或进程。
- `-a`,`-b`,`-o`：分别指定体系结构、位数和操作系统，通常是自动的，但也可以手动指定。
- `-w`：使用可写模式打开。





## gdb 基本工作原理

gdb 通过系统调用 `ptrace` 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。ptrace 系统调用的原型如下：

```
#include <sys/ptrace.h>long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);
```

- **pid_t pid**：指示 ptrace 要跟踪的进程。

- **void \*addr**：指示要监控的内存地址。

- **void \*data**：存放读取出的或者要写入的数据。

- enum __ptrace_request request

  ：决定了系统调用的功能，几个主要的选项：

  - *PTRACE_TRACEME*：表示此进程将被父进程跟踪，任何信号（除了 `SIGKILL`）都会暂停子进程，接着阻塞于 `wait()` 等待的父进程被唤醒。子进程内部对 `exec()` 的调用将发出 `SIGTRAP` 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它。
  - *PTRACE_ATTACH*：attach 到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用 `getppid()` 的到的仍将是其原始父进程的 pid。
  - *PTRACE_CONT*：继续运行之前停止的子进程。可同时向子进程交付指定的信号。

### gdb 的三种调试方式

- 运行并调试一个新进程

  - 运行 gdb，通过命令行或 `file` 命令指定目标程序。

  - 输入

     

    ```
    run
    ```

     

    命令， gdb 执行下面的操作：

    - 通过 `fork()` 系统调用创建一个新进程
    - 在新创建的子进程中执行操作：`ptrace(PTRACE_TRACEME, 0, 0, 0)`
    - 在子进程中通过 `execv()` 系统调用加载用户指定的可执行文件

- attach 并调试一个已经运行的进程

  - 用户确定需要进行调试的进程 PID
  - 运行 gdb，输入 `attach <pid>`，gdb 将对指定进程执行操作：`ptrace(PTRACE_ATTACH, pid, 0, 0)`

- 远程调试目标机上新创建的进程

  - gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据格式由 gdb 远程串行协议（Remote Serial Protocol）定义
  - RSP 协议数据的基本格式为： `$..........#xx`
  - gdbserver 的启动方式相当于运行并调试一个新创建的进程

注意，在你将 gdb attach 到一个进程时，可能会出现这样的问题：

```
gdb-peda$ attach 9091Attaching to process 9091ptrace: Operation not permitted.
```

这是因为开启了内核参数 `ptrace_scope`：

```
$ cat /proc/sys/kernel/yama/ptrace_scope1
```

1 表示 True，此时普通用户进程是不能对其他进程进行 attach 操作的，当然你可以用 root 权限启动 gdb，但最好的办法还是关掉它：

```
# echo 0 > /proc/sys/kernel/yama/ptrace_scope
```

### 断点的实现

断点的功能是通过内核信号实现的，在 x86 架构上，内核向某个地址打入断点，实际上就是往该地址写入断点指令 `INT 3`，即 `0xCC`。目标程序运行到这条指令之后会触发 `SIGTRAP` 信号，gdb 捕获这个信号，并根据目标程序当前停止的位置查询 gdb 维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。



## gdb 基本操作

使用 `-tui` 选项可以将代码显示在一个漂亮的交互式窗口中。

### break — b

- `break` 当不带参数时，在所选栈帧中执行的下一条指令处设置断点。
- `break <function>` 在函数体入口处打断点。
- `break <line>` 在当前源码文件指定行的开始处打断点。
- `break -N` `break +N` 在当前源码行前面或后面的 `N` 行开始处打断点，`N` 为正整数。
- `break <filename:line>` 在源码文件 `filename` 的 `line` 行处打断点。
- `break <filename:function>` 在源码文件 `filename` 的 `function` 函数入口处打断点。
- `break <address>` 在程序指令的地址处打断点。
- `break ... if <cond>` 设置条件断点，`...` 代表上述参数之一（或无参数），`cond` 为条件表达式，仅在 `cond` 值非零时停住程序。

### info

- ```
  info breakpoints -- i b
  ```

   

  查看断点，观察点和捕获点的列表。

  - `info breakpoints [list…]`
  - `info break [list…]`
  - `list…` 用来指定若干个断点的编号（可省略），可以是 `2`， `1-3`， `2 5` 等。

- `info display` 打印自动显示的表达式列表，每个表达式都带有项目编号，但不显示其值。

- `info reg` 显示当前寄存器信息。

- `info threads` 打印出所有线程的信息，包含 Thread ID、Target ID 和 Frame。

- `info frame` 打印出指定栈帧的详细信息。

- `info proc` 查看 proc 里的进程信息。

### disable — dis

禁用断点，参数使用空格分隔。不带参数时禁用所有断点。

- `disable [breakpoints] [list…]` `breakpoints` 是 `disable` 的子命令（可省略），`list…` 同 `info breakpoints` 中的描述。

### enable

启用断点，参数使用空格分隔。不带参数时启用所有断点。

- `enable [breakpoints] [list…]` 启用指定的断点（或所有定义的断点）。
- `enable [breakpoints] once list…` 临时启用指定的断点。GDB 在停止您的程序后立即禁用这些断点。
- `enable [breakpoints] delete list…` 使指定的断点启用一次，然后删除。一旦您的程序停止，GDB 就会删除这些断点。等效于用 `tbreak` 设置的断点。

`breakpoints` 同 `disable` 中的描述。

### clear

在指定行或函数处清除断点。参数可以是行号，函数名称或 `*` 跟一个地址。

- `clear` 当不带参数时，清除所选栈帧在执行的源码行中的所有断点。
- `clear <function>`, `clear <filename:function>` 删除在命名函数的入口处设置的任何断点。
- `clear <line>`, `clear <filename:line>` 删除在指定的文件指定的行号的代码中设置的任何断点。
- `clear <address>` 清除指定程序指令的地址处的断点。

### delete — d

删除断点。参数使用空格分隔。不带参数时删除所有断点。

- `delete [breakpoints] [list…]`

### tbreak

设置临时断点。参数形式同 `break` 一样。当第一次命中时被删除。

### watch

为表达式设置观察点。每当一个表达式的值改变时，观察点就会停止执行您的程序。

- `watch [-l|-location] <expr>` 如果给出了 `-l` 或者 `-location`，则它会对 `expr` 求值并观察它所指向的内存。

另外 `rwatch` 表示在访问时停止，`awatch` 表示在访问和改变时都停止。

### step — s

单步执行程序，直到到达不同的源码行。

- `step [N]` 参数 `N` 表示执行 N 次（或由于另一个原因直到程序停止）。

### reverse-step

反向步进程序，直到到达另一个源码行的开头。

- `reverse-step [N]` 参数 `N` 表示执行 N 次（或由于另一个原因直到程序停止）。

### next — n

单步执行程序，执行完子程序调用。

- `next [N]`

与 `step` 不同，如果当前的源代码行调用子程序，则此命令不会进入子程序，而是继续执行，将其视为单个源代码行。

### reverse-next

反向步进程序，执行完子程序调用。

- `reverse-next [N]`

如果要执行的源代码行调用子程序，则此命令不会进入子程序，调用被视为一个指令。

### return

您可以使用 `return` 命令取消函数调用的执行。如果你给出一个表达式参数，它的值被用作函数的返回值。

- `return <expression>` 将 `expression` 的值作为函数的返回值并使函数直接返回。

### finish — fin

执行直到选定的栈帧返回。

- `finish`

### until — u

执行程序直到大于当前栈帧或当前栈帧中的指定位置（与 `break` 命令相同的参数）的源码行。此命令常用于通过一个循环，以避免单步执行。

- `until <location>` 继续运行程序，直到达到指定的位置，或者当前栈帧返回。

### continue — c

在信号或断点之后，继续运行被调试的程序。

- `continue [N]`

如果从断点开始，可以使用数字 `N` 作为参数，这意味着将该断点的忽略计数设置为 `N - 1`(以便断点在第 N 次到达之前不会中断)。

### print — p

求表达式 expr 的值并打印。可访问的变量是所选栈帧的词法环境，以及范围为全局或整个文件的所有变量。

- `print [expr]`
- `print /f [expr]` 通过指定 `/f` 来选择不同的打印格式，其中 `f` 是一个指定格式的字母

### x

检查内存。

- `x/nfu <addr>`

- ```
  x <addr>
  ```

  - `n`, `f`, 和 `u` 都是可选参数，用于指定要显示的内存以及如何格式化。
  - `addr` 是要开始显示内存的地址的表达式。
  - `n` 重复次数（默认值是 1），指定要显示多少个单位（由 `u` 指定）的内存值。
  - `f` 显示格式（初始默认值是 `x`），显示格式是 `print('x'，'d'，'u'，'o'，'t'，'a'，'c'，'f'，'s')` 使用的格式之一，再加 `i`（机器指令）。
  - `u` 单位大小，`b` 表示单字节，`h` 表示双字节，`w` 表示四字节，`g` 表示八字节。

### display

每次程序停止时打印表达式 expr 的值。

- `display <expr>`
- `display/fmt <expr>`
- `display/fmt <addr>`

`fmt` 用于指定显示格式。对于格式 `i` 或 `s`，或者包括单位大小或单位数量，将表达式 `addr` 添加为每次程序停止时要检查的内存地址。

### disassemble — disas

反汇编命令。

- `disas <func>` 反汇编指定函数
- `disas <addr>` 反汇编某地址所在函数
- `disas <begin_addr> <end_addr>` 反汇编从开始地址到结束地址的部分

### undisplay

取消某些表达式在程序停止时自动显示。参数是表达式的编号（使用 `info display` 查询编号）。不带参数表示取消所有自动显示表达式。

### disable display

禁用某些表达式在程序停止时自动显示。禁用的显示项目被再次启用。参数是表达式的编号（使用 `info display` 查询编号）。不带参数表示禁用所有自动显示表达式。

### enable display

启用某些表达式在程序停止时自动显示。参数是重新显示的表达式的编号（使用 `info display` 查询编号）。不带参数表示启用所有自动显示表达式。

### help — h

打印命令列表。

- `help <class>` 您可以获取该类中各个命令的列表。
- `help <command>` 显示如何使用该命令的简述。

### attach

挂接到 GDB 之外的进程或文件。将进程 ID 或设备文件作为参数。

- `attach <process-id>`

### run — r

启动被调试的程序。可以直接指定参数，也可以用 `set args` 设置（启动所需的）参数。还允许使用 `>`, `<`, 或 `>>` 进行输入和输出重定向。

甚至可以运行一个脚本，如：

```
run `python2 -c 'print "A"*100'`
```

### backtrace — bt

打印整个栈的回溯。

- `bt` 打印整个栈的回溯，每个栈帧一行。
- `bt n` 类似于上，但只打印最内层的 n 个栈帧。
- `bt -n` 类似于上，但只打印最外层的 n 个栈帧。
- `bt full n` 类似于 `bt n`，还打印局部变量的值。

> 注意：使用 gdb 调试时，会自动关闭 ASLR，所以可能每次看到的栈地址都不变。

### ptype

打印类型 TYPE 的定义。

- `ptype[/FLAGS] TYPE-NAME | EXPRESSION`

参数可以是由 `typedef` 定义的类型名， 或者 `struct STRUCT-TAG` 或者 `class CLASS-NAME` 或者 `union UNION-TAG` 或者 `enum ENUM-TAG`。

### set follow-fork-mode

当程序 fork 出一个子进程的时候，gdb 默认会追踪父进程（`set follow-fork-mode parent`），但也可以使用命令 `set follow-fork-mode child` 让其追踪子进程。

另外，如果想要同时追踪父进程和子进程，可以使用命令 `set detach-on-fork off`（默认为`on`），这样就可以同时调试父子进程，在调试其中一个进程时，另一个进程被挂起。如果想让父子进程同时运行，可以使用 `set schedule-multiple on`（默认为`off`）。

但如果程序是使用 exec 来启动了一个新的程序，可以使用 `set follow-exec-mode new`（默认为`same`） 来新建一个 inferior 给新程序，而父进程的 inferior 仍然保留。

### thread apply all bt

打印出所有线程的堆栈信息。

### generate-core-file

将调试中的进程生成内核转储文件。

### directory — dir

设置查找源文件的路径。

或者使用 gdb 的 `-d` 参数，例如：`gdb a.out -d /search/code/`

## gdb-peda

当 gdb 启动时，它会在当前用户的主目录中寻找一个名为 `.gdbinit` 的文件；如果该文件存在，则 gdb 就执行该文件中的所有命令。通常，该文件用于简单的配置命令。但是 `.gdbinit` 的配置十分繁琐，因此对 gdb 的扩展通常用插件的方式来实现，通过 python 的脚本可以很方便的实现需要的功能。

PEDA（Python Exploit Development Assistance for GDB）是一个强大的 gdb 插件。它提供了高亮显示反汇编代码、寄存器、内存信息等人性化的功能。同时，PEDA 还有一些实用的新命令，比如 checksec 可以查看程序开启了哪些安全机制等等。

### 安装

安装 peda 需要的软件包：

```
$ sudo apt-get install nasm micro-inetd$ sudo apt-get install libc6-dbg vim ssh
```

安装 peda：

```
$ git clone https://github.com/longld/peda.git ~/peda$ echo "source ~/peda/peda.py" >> ~/.gdbinit$ echo "DONE! debug your program with gdb and enjoy"
```

如果系统为 Arch Linux，则可以直接安装：

```
$ yaourt -S peda
```

### peda命令

- **`aslr`** — 显示/设置 gdb 的 ASLR

- ```
  asmsearch
  ```

   

  — Search for ASM instructions in memory

  - `asmsearch "int 0x80"`
  - `asmsearch "add esp, ?" libc`

- ```
  assemble
  ```

   

  — On the fly assemble and execute instructions using NASM

  - `assemble`

  - ```
    assemble $pc> mov al, 0xb> int 0x80> end
    ```

- **`checksec`** — 检查二进制文件的安全选项

- ```
  cmpmem
  ```

   

  — Compare content of a memory region with a file

  - `cmpmem 0x08049000 0x0804a000 data.mem`

- ```
  context
  ```

   

  — Display various information of current execution context

  - `context_code` — Display nearby disassembly at $PC of current execution context

  - `context_register` — Display register information of current execution context

  - ```
    context_stack
    ```

     

    — Display stack of current execution context

    - `context reg`
    - `context code`
    - `context stack`

- `crashdump` — Display crashdump info and save to file

- ```
  deactive
  ```

   

  — Bypass a function by ignoring its execution (eg sleep/alarm)

  - `deactive setresuid`
  - `deactive chdir`

- `distance` — Calculate distance between two addresses

- **`dumpargs`** — 在调用指令停止时显示传递给函数的参数

- ```
  dumpmem
  ```

   

  — Dump content of a memory region to raw binary file

  - `dumpmem libc.mem libc`

- `dumprop`

   

  — 在特定的内存范围显示 ROP gadgets

  - `dumprop`
  - `dumprop binary "pop"`

- `eflags` — Display/set/clear/toggle value of eflags register

- `elfheader`

   

  — 获取正在调试的 ELF 文件的头信息

  - `elfheader`
  - `elfheader .got`

- `elfsymbol`

   

  — 从 ELF 文件中获取没有调试信息的符号信息

  - `elfsymbol`
  - `elfsymbol printf`

- ```
  gennop
  ```

   

  — Generate abitrary length NOP sled using given characters

  - `gennop 500`
  - `gennop 500 "\x90"`

- `getfile` — Get exec filename of current debugged process

- `getpid` — Get PID of current debugged process

- `goto` — Continue execution at an address

- `help` — Print the usage manual for PEDA commands

- ```
  hexdump
  ```

   

  — Display hex/ascii dump of data in memory

  - `hexdump $sp 64`
  - `hexdump $sp /20`

- ```
  hexprint
  ```

   

  — Display hexified of data in memory

  - `hexprint $sp 64`
  - `hexprint $sp /20`

- ```
  jmpcall
  ```

   

  — Search for JMP/CALL instructions in memory

  - `jmpcall`
  - `jmpcall eax`
  - `jmpcall esp libc`

- ```
  loadmem
  ```

   

  — Load contents of a raw binary file to memory

  - `loadmem stack.mem 0xbffdf000`

- `lookup`

   

  — 搜索属于内存范围的地址的所有地址/引用

  - `lookup address stack libc`
  - `lookup pointer stack ld-2`

- ```
  nearpc
  ```

   

  — Disassemble instructions nearby current PC or given address

  - `nearpc 20`
  - `nearpc 0x08048484`

- ```
  nextcall
  ```

   

  — Step until next ‘call’ instruction in specific memory range

  - `nextcall cpy`

- ```
  nextjmp
  ```

   

  — Step until next ‘j*’ instruction in specific memory range

  - `nextjmp`

- `nxtest` — Perform real NX test to see if it is enabled/supported by OS

- `patch`

   

  — 使用字符串/十六进制字符串/整形数

  - `patch $esp 0xdeadbeef`
  - `patch $eax "the long string"`
  - `patch (multiple lines)`

- `pattern`

   

  — 生成，搜索或写入循环 pattern 到内存

  - `pattern_arg` — Set argument list with cyclic pattern

  - `pattern_create` — Generate a cyclic pattern

  - `pattern_env` — Set environment variable with a cyclic pattern

  - `pattern_offset` — Search for offset of a value in cyclic pattern

  - `pattern_patch` — Write a cyclic pattern to memory

  - ```
    pattern_search
    ```

     

    — Search a cyclic pattern in registers and memory

    - `pattern create 2000`
    - `pattern create 2000 input`
    - `pattern offset $pc`
    - `pattern search`
    - `pattern patch 0xdeadbeef 100`

- ```
  payload
  ```

   

  — Generate various type of ROP payload using ret2plt

  - `payload copybytes`
  - `payload copybytes target "/bin/sh"`
  - `payload copybytes 0x0804a010 offset`

- ```
  pdisass
  ```

   

  — Format output of gdb disassemble command with colors

  - `pdisass $pc /20`

- ```
  pltbreak
  ```

   

  — Set breakpoint at PLT functions match name regex

  - `pltbreak cpy`

- `procinfo`

   

  — 显示调试进程的 /proc/pid/

  - `procinfo`
  - `procinfo fd`

- `profile` — Simple profiling to count executed instructions in the program

- ```
  pyhelp
  ```

   

  — Wrapper for python built-in help

  - `pyhelp peda`
  - `pyhelp hex2str`

- `pshow`

   

  — 显示各种 PEDA 选项和其他设置

  - `pshow`
  - `pshow option context`

- `pset`

   

  — 设置各种 PEDA 选项和其他设置

  - `pset arg '"A"*200'`
  - `pset arg 'cyclic_pattern(200)'`
  - `pset env EGG 'cyclic_pattern(200)'`
  - `pset option context "code,stack"`
  - `pset option badchars "\r\n"`

- `readelf`

   

  — 获取 ELF 的文件头信息

  - `readelf libc .text`

- ```
  refsearch
  ```

   

  — Search for all references to a value in memory ranges

  - `refsearch "/bin/sh"`
  - `refsearch 0xdeadbeef`

- `reload` — Reload PEDA sources, keep current options untouch

- `ropgadget`

   

  — 获取二进制或库的常见 ROP gadgets

  - `ropgadget`
  - `ropgadget libc`

- `ropsearch`

   

  — 搜索内存中的 ROP gadgets

  - `ropsearch "pop eax"`
  - `ropsearch "xchg eax, esp" libc`

- `searchmem|find`

   

  — 搜索内存中的 pattern; 支持正则表达式搜索

  - `find "/bin/sh" libc`
  - `find 0xdeadbeef all`
  - `find "..\x04\x08" 0x08048000 0x08049000`

- `searchmem` — Search for a pattern in memory; support regex search

- `session` — Save/restore a working gdb session to file as a script

- ```
  set
  ```

   

  — Set various PEDA options and other settings

  - `set exec-wrapper ./exploit.py`

- `sgrep` — Search for full strings contain the given pattern

- `shellcode`

   

  — 生成或下载常见的 shellcode

  - `shellcode x86/linux exec`

- `show` — Show various PEDA options and other settings

- `skeleton`

   

  — 生成 python exploit 代码模板

  - `skeleton argv exploit.py`

- `skipi` — Skip execution of next count instructions

- ```
  snapshot
  ```

   

  — Save/restore process’s snapshot to/from file

  - `snapshot save`
  - `snapshot restore`

- `start` — Start debugged program and stop at most convenient entry

- ```
  stepuntil
  ```

   

  — Step until a desired instruction in specific memory range

  - `stepuntil cmp`
  - `stepuntil xor`

- ```
  strings
  ```

   

  — Display printable strings in memory

  - `strings`
  - `strings binary 4`

- `substr` — Search for substrings of a given string/number in memory

- ```
  telescope
  ```

   

  — Display memory content at an address with smart dereferences

  - `telescope 40`
  - `telescope 0xb7d88000 40`

- ```
  tracecall
  ```

   

  — Trace function calls made by the program

  - `tracecall`
  - `tracecall "cpy,printf"`
  - `tracecall "-puts,fflush"`

- ```
  traceinst
  ```

   

  — Trace specific instructions executed by the program

  - `traceinst 20`
  - `traceinst "cmp,xor"`

- ```
  unptrace
  ```

   

  — Disable anti-ptrace detection

  - `unptrace`

- `utils` — Miscelaneous utilities from utils module

- `vmmap`

   

  — 在调试过程中获取段的虚拟映射地址范围

  - `cmmap`
  - `vmmap binary / libc`
  - `vmmap 0xb7d88000`

- ```
  waitfor
  ```

   

  — Try to attach to new forked process; mimic “attach -waitfor”

  - `waitfor`
  - `waitfor myprog -c`

- ```
  xinfo
  ```

   

  — Display detail information of address/registers

  - `xinfo register eax`
  - `xinfo 0xb7d88000`

- `xormem`

   

  — 用一个 key 来对一个内存区域执行 XOR 操作

  - `xormem 0x08049000 0x0804a000 “thekey”`

- `xprint` — Extra support to GDB’s print command

- `xrefs` — Search for all call/data access references to a function/variable

- `xuntil` — Continue execution until an address or function

### 使用 PEDA 和 Python 编写 gdb 脚本

- 全局类

  - ```
    pedacmd
    ```

    ：

    - 交互式命令
    - 没有返回值
    - 例如：`pedacmd.context_register()`

  - ```
    peda
    ```

    ：

    - 与 gdb 交互的后端功能
    - 有返回值
    - 例如：`peda.getreg("eax")`

- 小工具

  - 例如：`to_int()`、`format_address()`
  - 获得帮助
    - `pyhelp peda`
    - `pyhelp hex2str`

- 单行／交互式使用

  - `gdb-peda$ python print peda.get_vmmap()`

  - ```
    gdb-peda$ python> status = peda.get_status()> while status == "BREAKPOINT":>    peda.execute("continue")> end
    ```

- 外部脚本

  - ```
    # myscript.pydef myrun(size):    argv = cyclic_pattern(size)    peda.execute("set arg %s" % argv)    peda.execute("run")
    ```

    ```
    gdb-peda$ source myscript.pygdb-peda$ python myrun(100)
    ```

### 更多资料

http://ropshell.com/peda/

## GEF/pwndbg

除了 PEDA 外还有一些优秀的 gdb 增强工具，特别是增加了一些查看堆的命令，可以看情况选用。

- [GEF](https://github.com/hugsy/gef) - Multi-Architecture GDB Enhanced Features for Exploiters & Reverse-Engineers
- [pwndbg](https://github.com/pwndbg/pwndbg) - Exploit Development and Reverse Engineering with GDB Made Easy





# OllyDbg 调试器

- [快捷键](https://www.bookstack.cn/read/CTF-All-In-One/doc-2.3.2_ollydbg.md#快捷键)
- [命令行插件](https://www.bookstack.cn/read/CTF-All-In-One/doc-2.3.2_ollydbg.md#命令行插件)
- [参考资料](https://www.bookstack.cn/read/CTF-All-In-One/doc-2.3.2_ollydbg.md#参考资料)

## 快捷键

- `Ctrl`+`F1`：打开与所选行内符号相关的 API 帮助文档。
- `F2`：在光标选定位置按 F2 键设置或取消断点。
- `Shift`+`F2`：在首个选择命令设置条件断点。
- `Ctrl`+`F2`：重新启动被调试程序。
- `F4`：运行到光标选定位置处暂停。
- `Shift`+`F4`：设置记录断点。
- `F5`：最大化当前窗口。
- `Ctrl`+`F5`：打开与首个选择的命令相对应的源文件。
- `Alt`+`F5`：让 OllyDbg 窗口总在最前面。
- `F6`：切换到下一个窗口。
- `Shift`+`F6`：切换到前一个窗口。
- `F7`：单步步入：每次执行一条指令，遇到 call 等子程序时进入其中。
- `Shift`+`F7`：与 F7 相同，但当被调试程序发生异常而中止时，调试器首先尝试步入被调试程序指定的异常处理。
- `Ctrl`+`F7`：自动步入，在所有的函数调用中一条一条地执行命令。
- `Alt`+`F7`：转到上一个找到的参考。
- `F8`：单步步过，每次执行一条指令，遇到 call 等子程序时不进入其中。
- `Shift`+`F8`：与 F8 相同，但当被调试程序发生异常而中止时，调试器首先尝试步过被调试程序指定的异常处理。
- `Ctrl`+`F8`：自动步过，一条一条执行命令，但不进入函数内部调用。
- `Alt`+`F8`：转到下一个找到的参考。
- `F9`：运行，被调试软件继续运行，直到遇到下一个断点。
- `Shift`+`F9`：与 F9 相同，但当被调试程序发生异常而中止时，调试器首先尝试执行被调试程序指定的异常处理。
- `Ctrl`+`F9`：执行到返回，在执行到一个 ret 指令时暂停，常用于从当前函数快速返回到上一个函数。
- `Alt`+`F9`：执行到用户代码，可用于从系统部分快速返回到被调试程序部分。
- `F10`：打开与当前窗口或面板相关的快捷菜单。
- `Ctrl`+`F11`：Run 跟踪步入，一条一条执行命令，进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。
- `F12`：停止执行，暂停所有线程。
- `Ctrl`+`F12`：Run 跟踪步过，一条一条执行命令，不进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。
- `Alt`+`F3`：关闭当前窗口。
- `Alt`+`B`：显示断点窗口。
- `Alt`+`C`：显示 CPU 窗口。
- `Alt`+`E`：显示模块列表。
- `Alt`+`K`：显示调用栈。
- `Alt`+`L`：显示日志窗口。
- `Alt`+`M`：显示内存窗口。
- `Alt`+`O`：显示选项对话框。
- `Alt`+`Backspace`：撤销对所选部分的修改。
- `Ctrl`+`A`：分析当前模块的代码段。
- `Ctrl`+`B`：开始二进制搜索。
- `Ctrl`+`E`：以十六进制格式编辑所选内容。
- `Ctrl`+`F`：开始命令搜索。
- `Ctrl`+`G`：转到某地址。
- `Ctrl`+`J`：列出所有的涉及到该位置的调用和跳转。
- `Ctrl`+`K`：查看与当前函数相关的调用树。
- `Ctrl`+`L`：搜索下一个。
- `Ctrl`+`N`：打开当前模块的名称列表。
- `Ctrl`+`O`：扫描对象文件。
- `Ctrl`+`P`：显示补丁窗口。
- `Ctrl`+`R`：搜索所选命令的参考。
- `Ctrl`+`S`：命令搜索。
- `Ctrl`+`T`：打开“暂停Run跟踪”对话框。
- `Esc`：停止自动执行或跟踪。
- `Enter`：将选中的命令添加到命令历史，如果当前命令是一个跳转或者函数，则进入到目的地址。
- `Backspace`：如果分析器将代码误识为数据，可以将选中部分的自动分析信息移除。
- *：转到原始位置
- `Ctrl`+`*`：指定新的起始位置。
- `+`：如果 Run 跟踪没有激活，则根据历史命令跳到下一条运行过命令的地方；否则跳到 Run 跟踪的下一个记录。
- `Ctrl`+`+`：跳到前一个函数的开始处。
- `-`：如果 Run 跟踪没有激活，则根据历史命令跳到前一条运行过命令的地方；否则跳到 Run 跟踪的前一个记录。
- `Ctrl`+`-`：跳到下一个函数的开始处。
- `Space`：修改命令。
- `:`：添加标签。
- `;`：添加注释。



# x64dbg

- [快捷键](https://www.bookstack.cn/read/CTF-All-In-One/doc-2.3.3_x64dbg.md#快捷键)
- [参考资料](https://www.bookstack.cn/read/CTF-All-In-One/doc-2.3.3_x64dbg.md#参考资料)

## 快捷键

## 参考资料

- https://x64dbg.com/#start



# C 语言基础

- [从源代码到可执行文件](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.1_c_basic.md#从源代码到可执行文件)
- [C 语言标准库](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.1_c_basic.md#c-语言标准库)
- [整数表示](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.1_c_basic.md#整数表示)
- [格式化输出函数](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.1_c_basic.md#格式化输出函数)
- [关于 C++](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.1_c_basic.md#关于-c++)

## 从源代码到可执行文件

我们以经典著作《The C Programming Language》中的第一个程序 “Hello World” 为例，讲解 Linux 下 GCC 的编译过程。

```
#include <stdio.h>main(){    printf("hello, world\n");}
$gcc hello.c$./a.outhello world
```

以上过程可分为4个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。

![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.1_compile.png)

### 预编译

```
gcc -E hello.c -o hello.i
# 1 "hello.c"# 1 "<built-in>"# 1 "<command-line>"......extern int printf (const char *__restrict __format, ...);......main() { printf("hello, world\n");}
```

预编译过程主要处理源代码中以 “#” 开始的预编译指令：

- 将所有的 “#define” 删除，并且展开所有的宏定义。
- 处理所有条件预编译指令，如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
- 处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，该过程递归执行。
- 删除所有注释。
- 添加行号和文件名标号。
- 保留所有的 #pragma 编译器指令。

### 编译

```
gcc -S hello.c -o hello.s
        .file   "hello.c"        .section        .rodata.LC0:        .string "hello, world"        .text        .globl  main        .type   main, @functionmain:.LFB0:        .cfi_startproc        pushq   %rbp        .cfi_def_cfa_offset 16        .cfi_offset 6, -16        movq    %rsp, %rbp        .cfi_def_cfa_register 6        leaq    .LC0(%rip), %rdi        call    puts@PLT        movl    $0, %eax        popq    %rbp        .cfi_def_cfa 7, 8        ret        .cfi_endproc.LFE0:        .size   main, .-main        .ident  "GCC: (GNU) 7.2.0"        .section        .note.GNU-stack,"",@progbits
```

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。

### 汇编

```
$ gcc -c hello.s -o hello.o或者$gcc -c hello.c -o hello.o
$ objdump -sd hello.ohello.o:     file format elf64-x86-64Contents of section .text: 0000 554889e5 488d3d00 000000e8 00000000  UH..H.=......... 0010 b8000000 005dc3                      .....].Contents of section .rodata: 0000 68656c6c 6f2c2077 6f726c64 00        hello, world.Contents of section .comment: 0000 00474343 3a202847 4e552920 372e322e  .GCC: (GNU) 7.2. 0010 3000                                 0.Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001  .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000  ................ 0020 00000000 17000000 00410e10 8602430d  .........A....C. 0030 06520c07 08000000                    .R......Disassembly of section .text:0000000000000000 <main>:   0:   55                      push   %rbp   1:   48 89 e5                mov    %rsp,%rbp   4:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # b <main+0xb>   b:   e8 00 00 00 00          callq  10 <main+0x10>  10:   b8 00 00 00 00          mov    $0x0,%eax  15:   5d                      pop    %rbp  16:   c3                      retq
```

汇编器将汇编代码转变成机器可以执行的指令。

### 链接

```
gcc hello.o -o hello
$ objdump -d -j .text hello......000000000000064a <main>: 64a:   55                      push   %rbp 64b:   48 89 e5                mov    %rsp,%rbp 64e:   48 8d 3d 9f 00 00 00    lea    0x9f(%rip),%rdi        # 6f4 <_IO_stdin_used+0x4> 655:   e8 d6 fe ff ff          callq  530 <puts@plt> 65a:   b8 00 00 00 00          mov    $0x0,%eax 65f:   5d                      pop    %rbp 660:   c3                      retq 661:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1) 668:   00 00 00 66b:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)......
```

目标文件需要链接一大堆文件才能得到最终的可执行文件（上面只展示了链接后的 main 函数，可以和 hello.o 中的 main 函数作对比）。链接过程主要包括地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定向（Relocation）等。

### gcc 技巧

通常在编译后只会生成一个可执行文件，而中间过程生成的 `.i`、`.s`、`.o` 文件都不会被保存。我们可以使用参数 `-save-temps` 永久保存这些临时的中间文件。

```
$ gcc -save-temps hello.c$ lsa.out hello.c  hello.i  hello.o  hello.s
```

这里要注意的是，gcc 默认使用动态链接，所以这里生成的 a.out 实际上是共享目标文件。

```
$ file a.outa.out: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=533aa4ca46d513b1276d14657ec41298cafd98b1, not stripped
```

使用参数 `--verbose` 可以输出 gcc 详细的工作流程。

```
gcc hello.c -static --verbose
```

东西很多，我们主要关注下面几条信息：

```
$ /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/cc1 -quiet -v hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -o /tmp/ccj1jUMo.sas -v --64 -o /tmp/ccAmXrfa.o /tmp/ccj1jUMo.s/usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/lto-wrapper -plugin-opt=-fresolution=/tmp/cc1l5oJV.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --build-id --hash-style=gnu -m elf_x86_64 -static /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../lib/crt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/crtbeginT.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../.. /tmp/ccAmXrfa.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/crtend.o /usr/lib/gcc/x86_64-pc-linux-gnu/7.2.0/../../../../lib/crtn.o
```

三条指令分别是 `cc1`、`as` 和 `collect2`，cc1 是 gcc 的编译器，将 `.c` 文件编译为 `.s` 文件，as 是汇编器命令，将 `.s` 文件汇编成 `.o` 文件，collect2 是链接器命令，它是对命令 ld 的封装。静态链接时，gcc 将 C 语言运行时库的 5 个重要目标文件 `crt1.o`、`crti.o`、`crtbeginT.o`、`crtend.o`、`crtn.o` 和 `-lgcc`、`-lgcc_eh`、`-lc` 表示的 3 个静态库链接到可执行文件中。

更多的内容我们会在 1.5.3 中专门对 ELF 文件进行讲解。

## C 语言标准库

C 运行库（CRT）是一套庞大的代码库，以支撑程序能够正常地运行。其中 C 语言标准库占据了最主要地位。

常用的标准库文件头：

- 标准输入输出（stdio.h）
- 字符操作（ctype.h）
- 字符串操作（string.h）
- 数学函数（math.h）
- 实用程序库（stdlib.h）
- 时间／日期（time.h）
- 断言（assert.h）
- 各种类型上的常数（limits.h & float.h）
- 变长参数（stdarg.h）
- 非局部跳转（setjmp.h）

glibc 即 GNU C Library，是为 GNU 操作系统开发的一个 C 标准库。glibc 主要由两部分组成，一部分是头文件，位于 `/usr/include`；另一部分是库的二进制文件。二进制文件部分主要是 C 语言标准库，有动态和静态两个版本，动态版本位于 `/lib/libc.so.6`，静态版本位于 `/usr/lib/libc.a`。

在漏洞利用的过程中，通常我们通过计算目标函数地址相对于已知函数地址在同一个 libc 中的偏移，来获得目标函数的虚拟地址，这时我们需要让本地的 libc 版本和远程的 libc 版本相同，可以先泄露几个函数的地址，然后在 [libcdb.com](http://libcdb.com/) 中进行搜索来得到。

## 整数表示

默认情况下，C 语言中的数字是有符号数，下面我们声明一个有符号整数和无符号整数：

```
int var1 = 0;unsigned int var2 = 0;
```

- 有符号整数
  - 可以表示为正数或负数
  - `int` 的范围：`-2,147,483,648 ~ 2,147,483,647`
- 无符号整数
  - 只能表示为零或正数
  - `unsigned int` 的范围：`0 ~ 4,294,967,295`

`signed` 或者 `unsigned` 取决于整数类型是否可以携带标志 `+/-`：

- Signed
  - int
  - signed int
  - long
- Unsigned
  - unit
  - unsigned int
  - unsigned long

在 `signed int` 中，二进制最高位被称作符号位，符号位被设置为 `1` 时，表示值为负，当设置为 `0` 时，值为非负：

- 0x7FFFFFFF = 2147493647
  - 01111111111111111111111111111111
- 0x80000000 = -2147483647
  - 10000000000000000000000000000000
- 0xFFFFFFFF = -1
  - 11111111111111111111111111111111

二进制补码以一种适合于二进制加法器的方式来表示负数，当一个二进制补码形式表示的负数和与它的绝对值相等的正数相加时，结果为 0。首先以二进制方式写出正数，然后对所有位取反，最后加 1 就可以得到该数的二进制补码：

```
eg: 0x00123456  = 1193046  = 00000000000100100011010001010110 ~= 11111111111011011100101110101001 += 11111111111011011100101110101010  = -1193046 (0xFFEDCBAA)
```

编译器需要根据变量类型信息编译成相应的指令：

- 有符号指令
  - IDIV：带符号除法指令
  - IMUL：带符号乘法指令
  - SAL：算术左移指令（保留符号）
  - SAR：右移右移指令（保留符号）
  - MOVSX：带符号扩展传送指令
  - JL：当小于时跳转指令
  - JLE：当小于或等于时跳转指令
  - JG：当大于时跳转指令
  - JGE：当大于或等于时跳转指令
- 无符号指令
  - DIV：除法指令
  - MUL：乘法指令
  - SHL：逻辑左移指令
  - SHR：逻辑右移指令
  - MOVZX：无符号扩展传送指令
  - JB：当小于时跳转指令
  - JBE：当小于或等于时跳转指令
  - JA：当大于时跳转指令
  - JAE：当大于或等于时跳转指令

32 位机器上的整型数据类型，不同的系统可能会有不同：

| C 数据类型 | 最小值                     | 最大值                    | 最小大小 |
| :--------- | :------------------------- | :------------------------ | :------- |
| char       | -128                       | 127                       | 8 bits   |
| short      | -32 768                    | 32 767                    | 16 bits  |
| int        | -2 147 483 648             | 2 147 483 647             | 16 bits  |
| long       | -2 147 483 648             | 2 147 483 647             | 32 bits  |
| long long  | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807 | 64 bits  |

固定大小的数据类型：

- ```
  int [# of bits]_t
  ```

  - int8_t, int16_t, int32_t

- `uint[# of bits]_t`

  - uint8_t, uint16_t, uint32_t

- 有符号整数

  - ![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.1_signed_integer.png)

- 无符号整数

  - ![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.1_unsigned_integer.png)

更多信息在 `stdint.h` 和 `limits.h` 中：

```
man stdint.hcat /usr/include/stdint.hman limits.hcat /usr/include/limits.h
```

了解整数的符号和大小是很有用的，在后面的相关章节中我们会介绍整数溢出的内容。

## 格式化输出函数

C 标准中定义了下面的格式化输出函数（参考 `man ３ printf`）：

```
#include <stdio.h>int printf(const char *format, ...);int fprintf(FILE *stream, const char *format, ...);int dprintf(int fd, const char *format, ...);int sprintf(char *str, const char *format, ...);int snprintf(char *str, size_t size, const char *format, ...);#include <stdarg.h>int vprintf(const char *format, va_list ap);int vfprintf(FILE *stream, const char *format, va_list ap);int vdprintf(int fd, const char *format, va_list ap);int vsprintf(char *str, const char *format, va_list ap);int vsnprintf(char *str, size_t size, const char *format, va_list ap);
```

- `fprintf()` 按照格式字符串的内容将输出写入流中。三个参数为流、格式字符串和变参列表。
- `printf()` 等同于 `fprintf()`，但是它假定输出流为 `stdout`。
- `sprintf()` 等同于 `fprintf()`，但是输出不是写入流而是写入数组。在写入的字符串末尾必须添加一个空字符。
- `snprintf()` 等同于 `sprintf()`，但是它指定了可写入字符的最大值 `size`。当 `size` 大于零时，输出字符超过第 `size-1` 的部分会被舍弃而不会写入数组中，在写入数组的字符串末尾会添加一个空字符。
- `dprintf()` 等同于 `fprintf()`，但是它输出不是流而是一个文件描述符 `fd`。
- `vfprintf()`、`vprintf()`、`vsprintf()`、`vsnprintf()`、`vdprintf()` 分别与上面的函数对应，只是它们将变参列表换成了 `va_list` 类型的参数。

### 格式字符串

格式字符串是由普通字符（ordinary character）（包括 `%`）和转换规则（conversion specification）构成的字符序列。普通字符被原封不动地复制到输出流中。转换规则根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中。

一个转换规则有可选部分和必需部分组成：

```
%[ 参数 ][ 标志 ][ 宽度 ][ .精度 ][ 长度 ] 转换指示符
```

- （必需）转换指示符

| 字符     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `d`, `i` | 有符号十进制数值 `int`。’`%d`‘ 与 ‘`%i`‘ 对于输出是同义；但对于 `scanf()` 输入二者不同，其中 `%i` 在输入值有前缀 `0x` 或 `0` 时，分别表示 16 进制或 8 进制的值。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空 |
| `u`      | 十进制 `unsigned int`。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空 |
| `f`, `F` | `double` 型输出 10 进制定点表示。’`f`‘ 与 ‘`F`‘ 差异是表示无穷与 NaN 时，’`f`‘ 输出 ‘`inf`‘, ‘`infinity`‘ 与 ‘`nan`‘；’`F`‘ 输出 ‘`INF`‘, ‘`INFINITY`‘ 与 ‘`NAN`‘。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为 6。如果精度为 0 且没有 # 标记，则不出现小数点。小数点左侧至少一位数字 |
| `e`, `E` | `double` 值，输出形式为 10 进制的([`-`]d.ddd `e`[`+`/`-`]ddd). `E` 版本使用的指数符号为 `E`（而不是`e`）。指数部分至少包含 2 位数字，如果值为 0，则指数部分为 00。Windows 系统，指数部分至少为 3 位数字，例如 1.5e002，也可用 Microsoft 版的运行时函数 `_set_output_format` 修改。小数点前存在 1 位数字。小数点后的数字位数等于精度。精度默认为 6。如果精度为 0 且没有 # 标记，则不出现小数点 |
| `g`, `G` | `double` 型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。’`g`‘ 使用小写字母，’`G`‘ 使用大写字母。小数点右侧的尾数 0 不被显示；显示小数点仅当输出的小数部分不为 0 |
| `x`, `X` | 16 进制 `unsigned int`。’`x`‘ 使用小写字母；’`X`‘ 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空 |
| `o`      | 8 进制 `unsigned int`。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空 |
| `s`      | 如果没有用 `l` 标志，输出 `null` 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 `l` 标志，则对应函数参数指向 `wchar_t` 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 `wcrtomb` 函数 |
| `c`      | 如果没有用 `l` 标志，把 `int` 参数转为 `unsigned char` 型输出；如果用了 `l` 标志，把 `wint_t` 参数转为包含两个元素的 `wchart_t` 数组，其中第一个元素包含要输出的字符，第二个元素为 `null` 宽字符 |
| `p`      | `void *` 型，输出对应变量的值。`printf("%p", a)` 用地址的格式打印变量 `a` 的值，`printf("%p", &a)` 打印变量 `a` 所在的地址 |
| `a`, `A` | `double` 型的 16 进制表示，”[−]0xh.hhhh p±d”。其中指数部分为 10 进制表示的形式。例如：1025.010 输出为 0x1.004000p+10。’`a`‘ 使用小写字母，’`A`‘ 使用大写字母 |
| `n`      | 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量 |
| `%`      | ‘`%`‘ 字面值，不接受任何除了 `参数` 以外的部分               |

- （可选）参数

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `n$` | `n` 是用这个格式说明符显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了 `参数`，则其他所有占位符必须也使用 `参数`。例：`printf("%2$d %2$#x; %1$d %1$#x",16,17)` 产生 “`17 0x11; 16 0x10`“ |

- （可选）标志

| 字符   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| `+`    | 总是表示有符号数值的 ‘`+`‘ 或 ‘`-`‘ 号，缺省情况是忽略正数的符号。仅适用于数值类型 |
| *空格* | 使得有符号数的输出如果没有正负号或者输出 0 个字符，则前缀 1 个空格。如果空格与 ‘`+`‘ 同时出现，则空格说明符被忽略 |
| `-`    | 左对齐。缺省情况是右对齐                                     |
| `#`    | 对于 ‘`g`‘ 与 ‘`G`‘，不删除尾部 0 以表示精度。对于 ‘`f`‘, ‘`F`‘, ‘`e`‘, ‘`E`‘, ‘`g`‘, ‘`G`‘, 总是输出小数点。对于 ‘`o`‘, ‘`x`‘, ‘`X`‘, 在非 0 数值前分别输出前缀 `0`, `0x` 和 `0X`表示数制 |
| `0`    | 如果 `宽度` 选项前缀为 `0`，则在左侧用 `0` 填充直至达到宽度要求。例如 `printf("%2d", 3)` 输出 “`3`“，而 `printf("%02d", 3)` 输出 “`03`“。如果 `0` 与 `-` 均出现，则 `0` 被忽略，即左对齐依然用空格填充 |

- （可选）宽度

是一个用来指定输出字符的最小个数的十进制非负整数。如果实际位数多于定义的宽度,则按实际位数输出；如果实际位数少于定义的宽度则补以空格或 0。

- （可选）精度

精度是用来指示打印字符个数、小数位数或者有效数字个数的非负十进制整数。对于 `d`、`i`、`u`、`x`、`o` 的整型数值，是指最小数字位数，不足的位要在左侧补 0，如果超过也不截断，缺省值为 1。对于 `a`, `A`, `e`, `E`, `f`, `F` 的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入；缺省值为 6。对于 `g`, `G` 的浮点数值，是指有效数字的最大位数。对于 `s` 的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。如果域宽为 `*`，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为 0。

- （可选）长度

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `hh` | 对于整数类型，`printf` 期待一个从 `char` 提升的 `int` 整型参数 |
| `h`  | 对于整数类型，`printf` 期待一个从 `short` 提升的 `int` 整型参数 |
| `l`  | 对于整数类型，`printf` 期待一个 `long` 整型参数。对于浮点类型，`printf` 期待一个 `double` 整型参数。对于字符串 `s` 类型，`printf` 期待一个 `wchar_t` 指针参数。对于字符 `c` 类型，`printf` 期待一个 `wint_t` 型的参数 |
| `ll` | 对于整数类型，`printf` 期待一个 `long long` 整型参数。Microsoft 也可以使用 `I64` |
| `L`  | 对于浮点类型，`printf` 期待一个 `long double` 整型参数       |
| `z`  | 对于整数类型，`printf` 期待一个 `size_t` 整型参数            |
| `j`  | 对于整数类型，`printf` 期待一个 `intmax_t` 整型参数          |
| `t`  | 对于整数类型，`printf` 期待一个 `ptrdiff_t` 整型参数         |

### 例子

```
printf("Hello %%");           // "Hello %"printf("Hello World!");       // "Hello World!"printf("Number: %d", 123);    // "Number: 123"printf("%s %s", "Format", "Strings");   // "Format Strings"printf("%12c", 'A');          // "           A"printf("%16s", "Hello");      // "          Hello!"int n;printf("%12c%n", 'A', &n);    // n = 12printf("%16s%n", "Hello!", &n); // n = 16printf("%2$s %1$s", "Format", "Strings"); // "Strings Format"printf("%42c%1$n", &n);       // 首先输出41个空格，然后输出 n 的低八位地址作为一个字符
```

这里我们对格式化输出函数和格式字符串有了一个详细的认识，后面的章节中我们会介绍格式化字符串漏洞的内容。





# 汇编语言

- [汇编语言](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#汇编语言)
  - 3.3 X86 汇编基础
    - [3.3.2 寄存器 Registers](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#332-寄存器-registers)
    - 3.3.3 内存和寻址模式 Memory and Addressing Modes
      - [3.3.3.1 声明静态数据区域](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3331-声明静态数据区域)
      - [3.3.3.2 内存寻址](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3332-内存寻址)
      - [3.3.3.3 操作后缀](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3333-操作后缀)
    - 3.3.4 指令 Instructions
      - [3.3.4.1 数据移动指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3341-数据移动指令)
      - [3.3.4.2 逻辑运算指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3342-逻辑运算指令)
      - [3.3.4.3 流程控制指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3343-流程控制指令)
    - 3.3.5 调用约定 Calling Convention
      - [3.3.5.1 调用者约定 Caller Rules](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3351-调用者约定-caller-rules)
      - [3.3.5.2 被调用者约定 Callee Rules](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#3352-被调用者约定-callee-rules)
  - [3.4 x64 汇编基础](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#34-x64-汇编基础)
    - [3.4.1 导语](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#341-导语)
    - [3.4.2 寄存器 Registers](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#342-寄存器-registers)
    - [3.4.3 寻址模式 Addressing modes](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#343-寻址模式-addressing-modes)
    - 3.4.4 通用指令 Common instructions
      - [`mov` 和 `lea` 指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#mov-和-lea-指令)
      - [算术和位运算](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#算术和位运算)
      - [流程控制指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#流程控制指令)
      - [`setx`和`movx`](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#setx和movx)
      - [函数调用与栈](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#函数调用与栈)
      - [3.4.5 汇编和 gdb](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#345-汇编和-gdb)
  - 3.5 ARM汇编基础
    - [3.5.1 引言](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#351-引言)
    - [3.5.2 ARM 的 GNU 汇编程序指令表](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#352-arm-的-gnu-汇编程序指令表)
    - [3.5.3 寄存器名称](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#353-寄存器名称)
    - [3.5.4 汇编程序特殊字符/语法](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#354-汇编程序特殊字符语法)
    - [3.5.5 arm程序调用标准](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#355-arm程序调用标准)
    - [3.5.6 寻址模式](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#356-寻址模式)
    - [3.5.7 机器相关指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#357-机器相关指令)
  - 3.6 MIPS汇编基础
    - [数据类型和常量](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#数据类型和常量)
    - [寄存器](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#寄存器)
    - 程序结构
      - [数据声明](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#数据声明)
      - [代码](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#代码)
      - [注释](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#注释)
      - [变量声明](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#变量声明)
      - [读取/写入 ( Load/Store )指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#读取写入--loadstore-指令)
    - [间接和立即寻址](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#间接和立即寻址)
    - [算术指令](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#算术指令)
    - [流程控制](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#流程控制)
    - [系统调用和 I / O（ 针对 SPIM 模拟器 ）](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.2_assembly.md#系统调用和-i--o-针对-spim-模拟器-)

## 3.3 X86 汇编基础

------

### 3.3.2 寄存器 Registers

现代 ( 386及以上的机器 )x86 处理器有 8 个 32 位通用寄存器, 如图 1 所示.![x86-registers.png](https://static.sitestack.cn/projects/CTF-All-In-One/cc6c7545d271460bb64e2e0a0e01cc6d.png)

这些寄存器的名字都是有点历史的, 例如 EAX 过去被称为 *累加器*, 因为它被用来作很多算术运算, 还有 `ECX` 被称为 *计数器* , 因为它被用来保存循环的索引 ( 就是循环次数 ). 尽管大多是寄存器在现代指令集中已经失去了它们的特殊用途, 但是按照惯例, 其中有两个寄存器还是有它们的特殊用途 —-`ESP` 和 EBP.

对于 `EAS`, `EBX`, `ECX` 还有 `EDX` 寄存器, 它们可以被分段开来使用. 例如, 可以将 `EAX` 的最低的 2 位字节视为 16 位寄存器 ( `AX` ). 还可以将 `AX` 的最低位的 1 个字节看成 8 位寄存器来用 ( `AL` ), 当然 `AX` 的高位的 1 个字节也可以看成是一个 8 位寄存器 ( `AH` ). 这些名称有它们相对应的物理寄存器. 当两个字节大小的数据被放到 `DX` 的时候, 原本 `DH`, `DL` 和 `EDX` 的数据会受到影响 ( 被覆盖之类的 ). 这些 “ 子寄存器 “ 主要来自于比较久远的 16 位版本指令集. 然而, 姜还是老的辣, 在处理小于 32 位的数据的时候, 比如 1 个字节的 ASCII 字符, 它们有时会很方便.

### 3.3.3 内存和寻址模式 Memory and Addressing Modes

#### 3.3.3.1 声明静态数据区域

你可以用特殊的 x86 汇编指令在内存中声明静态数据区域 ( 类似于全局变量 ). `.data`指令用来声明数据. 根据这条指令, `.byte`, `.short` 和 `.long` 可以分别用来声明 1 个字节, 2 个字节和 4 个字节的数据. 我们可以给它们打个标签, 用来引用创建的数据的地址. 标签在汇编语言中是非常有用的, 它们给内存地址命名, 然后*编译器* 和*链接器* 将其 “ 翻译 “ 成计算机理解的机器代码. 这个跟用名称来声明变量很类似, 但是它遵守一些较低级别的规则. 例如, 按顺序声明的位置将彼此相邻地存储在内存中. 这话也许有点绕, 就是按照顺序打的标签, 这些标签对应的数据也会按照顺序被放到内存中.

一些例子 :

```
.datavar :       .byte 64 ;声明一个字节型变量 var, 其所对应的数据是64       .byte 10 ;声明一个数据 10, 这个数据没有所谓的 " 标签 ", 它的内存地址就是 var+1.x :       .short 42 ;声明一个大小为 2 个字节的数据, 这个数据有个标签 " x "y :       .long 30000 ;声明一个大小为 4 个字节的数据, 这个数据标签是 " y ",  y 的值被初始化为 30000
```

与高级语言不同, 高级语言的数组可以具有多个维度并且可以通过索引来访问, x86 汇编语言的数组只是在内存中连续的” 单元格 “. 你只需要把数值列出来就可以声明一个数组, 比如下面的第一个例子. 对于一些字节型数组的特殊情况, 我们可以使用字符串. 如果要在大多数的内存填充 0, 你可以使用`.zero`指令.

例子 :

```
s :       .long 1, 2, 3 ;声明 3 个大小为 4 字节的数据 1, 2, 3. 内存中 s+8 这个标签所对应的数据就是 3.barr:       .zero 10 ;从 barr 这个标签的位置开始, 声明 10 个字节的数据, 这些数据被初始化为 0.str :       .string "hello" ;从 str 这个标签的位置开始, 声明 6 个字节的数据, 即 hello 对应的 ASCII 值, 这最后还跟有一个 nul(0) 字节.
```

![label_s](https://static.sitestack.cn/projects/CTF-All-In-One/d49bcc5564003168e41dbef9ba4d3d10.png)

![label_barr](https://static.sitestack.cn/projects/CTF-All-In-One/678e0ed5c61c26ef6d536af1e2187c25.png)

![label_str](https://static.sitestack.cn/projects/CTF-All-In-One/bb77b04bedb9a1097c3ae6c5e5365fa1.png)

#### 3.3.3.2 内存寻址

现代x86兼容处理器能够寻址高达 2^32 字节的内存 : 内存地址为 32 位宽. 在上面的示例中，我们使用标签来引用内存区域，这些标签实际上被 32 位数据的汇编程序替换，这些数据指定了内存中的地址. 除了支持通过标签（即常数值）引用存储区域之外，x86提供了一种灵活的计算和引用内存地址的方案 ：最多可将两个32位寄存器和一个32位有符号常量相加，以计算存储器地址. 其中一个寄存器可以选择预先乘以 2, 4 或 8.

寻址模式可以和许多 x86 指令一起使用 ( 我们将在下一节对它们进行讲解 ). 这里我们用`mov`指令在寄存器和内存中移动数据当作例子. 这个指令有两个参数, 第一个是数据的来源, 第二个是数据的去向.

一些`mov`的例子 :

```
mov (%ebx), %eax ;从 EBX 中的内存地址加载 4 个字节的数据到 EAX, 就是把 EBX 中的内容当作标签, 这个标签在内存中对应的数据放到 EAX 中;后面如果没有说明的话, (%ebx)就表示寄存器ebx中存储的内容mov %ebx, var(,1) ; 将 EBX 中的 4 个字节大小的数据移动的内存中标签为 var 的地方去.( var 是一个 32 位常数).mov (%esi, %ebx, 4), %edx ;将内存中标签为 ESI+4*EBX 所对应的 4 个字节大小的数据移动到 EDX中.
```

一些**错误**的例子:

```
mov (%ebx, %ecx, -1), %eax ;这个只能把寄存器中的值加上一遍.mov %ebx,(%eax, %esi, %edi, 1) ;在地址计算中, 最多只能出现 2 个寄存器, 这里却有 3 个寄存器.
```

#### 3.3.3.3 操作后缀

通常, 给定内存地址的数据类型可以从引用它的汇编指令推断出来. 例如, 在上面的指令中, 你可以从寄存器操作数的大小来推出其所占的内存大小. 当我们加载一个 32 位的寄存器的时候, 编译器就可以推断出我们用到的内存大小是 4 个字节宽. 当我们将 1 个字节宽的寄存器的值保存到内存中时, 编译器可以推断出我们想要在内存中弄个 1 字节大小的 “ 坑 “ 来保存我们的数据.

然而在某些情况下, 我们用到的内存中 “ 坑 “ 的大小是不明确的. 比如说这条指令 `mov $2,(%ebx)`. 这条指令是否应该将 “ 2 “ 这个值移动到 EBX 中的值所代表的地址 “ 坑 “ 的单个字节中 ? 也许它表示的是将 32 位整数表示的 2 移动到从地址 EBX 开始的 4 字节. 既然这两个解释都有道理, 但计算机汇编程序必须明确哪个解释才是正确的, 计算机很单纯的, 要么是错的要么是对的. 前缀 b, w, 和 l 就是来解决这个问题的, 它们分别表示 1, 2 和 4 个字节的大小.

举几个例子 :

```
movb $2, (%ebx) ;将 2 移入到 ebx 中的值所表示的地址单元中.movw $2, (%ebx) ;将 16 位整数 2 移动到 从 ebx 中的值所表示的地址单元 开始的 2 个字节中;这话有点绕, 所以我故意在里面加了点空格, 方便大家理解.movl $2,(%ebx) ;将 32 位整数 2 移动到 从 ebx中的值表示的地址单元 开始的 4 个字节中.
```

### 3.3.4 指令 Instructions

机器指令通常分为 3 类 : 数据移动指令, 逻辑运算指令和流程控制指令. 在本节中, 我们将讲解每一种类型的 x86 指令以及它们的重要示例. 当然, 我们不可能把 x86 所有指令讲得特别详细, 毕竟篇幅和水平有限. 完整的指令列表, 请参阅 intel 的指令集参考手册.

我们将使用以下符号 :

```
<reg32 任意的 32 位寄存器 (%eax, %ebx, %ecx, %edx, %esi, %edi, %esp 或者 %eb)<reg16 任意的 16 位寄存器 (%ax, %bx, %cx 或者 %dx)<reg8 任意的 8 位寄存器 (%ah, %al, %bh, %bl, %ch, %cl, %dh, %dl)<reg 任意的寄存器<mem 一个内存地址, 例如 (%eax), 4+var, (%eax, %ebx, 1)<con32 32 位常数<con16 16 位常数<con8 8 位常数<con 任意 32位, 16 位或者 8 位常数
```

在汇编语言中, 用作*立即操作数* 的所有标签和数字常量 ( 即不在诸如`3 (%eax, %ebx, 8)`这样的地址计算中 ) 总是以美元符号 $ 为前缀. 需要的时候, 前缀 0x 表示十六进制数, 例如`$ 0xABC`. 如果没有前缀, 则默认该数字为十进制数.

#### 3.3.4.1 数据移动指令

- `mov` 移动

`mov` 指令将数据从它的第一个参数 ( 即寄存器中的内容, 内存单元中的内容, 或者一个常数值 ) 复制到它的第二个参数 ( 即寄存器或者内存单元 ). 当寄存器到寄存器之间的数据移动是可行的时候, 直接地从内存单元中将数据移动到另一内存单元中是不行的. 在这种需要在内存单元中传递数据的情况下, 它数据来源的那个内存单元必须首先把那个内存单元中的数据加载到一个寄存器中, 然后才可以通过这个寄存器来把数据移动到目标内存单元中.

- *语法*

```
mov <reg, <regmov <reg, <memmov <mem, <regmov <con, <regmov <con, <mem
```

- *例子*

```
mov %ebx, %eax ;将 EBX 中的值复制到 EAX 中mov $5, var(,1) ;将数字 5 存到字节型内存单元 " var "
```

![mov_1](https://static.sitestack.cn/projects/CTF-All-In-One/e7eee3d2810f09fd2d865e6688ae88e2.png)

- `push` 入栈

`push`指令将它的参数移动到硬件支持的**栈**内存顶端. 特别地, `push` 首先将 ESP 中的值减少 4, 然后将它的参数移动到一个 32 位的地址单元 ( %esp ). ESP ( 栈指针 ) 会随着不断入栈从而持续递减, 即栈内存是从高地址单元到低地址单元增长.

- *语法*

```
push <reg32push <mempush <con32
```

- *例子*

```
push %eax ;将 EAX 送入栈push var(,1) ;将 var 对应的 4 字节大小的数据送入栈中
```

- `pop` 出栈

`pop`指令从硬件支持的栈内存顶端移除 4 字节的数据, 并把这个数据放到该指令指定的参数中 ( 即寄存器或者内存单元 ). 其首先将内存中 ( %esp ) 的 4 字节数据放到指定的寄存器或者内存单元中, 然后让 ESP + 4.

- *语法*

```
pop <reg32pop <mem
```

- *例子*

```
pop %edi ;将栈顶的元素移除, 并放入到寄存器 EDI 中.pop (%ebx) ;将栈顶的元素移除, 并放入从 EBX 开始的 4 个字节大小的内存单元中.
```

重点内容 : 栈栈是一种特殊的存储空间, 特殊在它的访问形式上, 它的访问形式就是最后进入这个空间的数据, 最先出去, 也就是 “先进后出, 后进先出”.

- `lea`加载有效地址

`lea`指令将其第一个参数指定的内存单元 放入到 第二个参数指定的寄存器中. 注意, 该指令不加载内存单元中的内容, 只是计算有效地址并将其放入寄存器. 这对于获得指向存储器区域的指针或者执行简单的算术运算非常有用.

也许这里你会看得一头雾水, 不过你不必担心, 这里有更为通俗易懂的解释.**汇编语言中 lea 指令和 mov 指令的区别 ?**`MOV` 指令的功能是传送数据，例如 `MOV AX,[1000H]`，作用是将 1000H 作为偏移地址，寻址找到内存单元，将该内存单元中的数据送至 AX；`LEA` 指令的功能是取偏移地址，例如 `LEA AX,[1000H]`，作用是将源操作数 [1000H] 的偏移地址 1000H 送至 AX。理解时，可直接将[ ]去掉，等同于 `MOV AX,1000H`。再如：`LEA BX,[AX]`，等同于 `MOV BX,AX`；`LEA BX,TABLE` 等同于 `MOV BX,OFFSET TABLE`。但有时不能直接使用 `MOV` 代替：比如：`LEA AX,[SI+6]` 不能直接替换成：`MOV AX,SI+6`；但可替换为：`MOV AX,SI``ADD AX,6`两步完成。

[参考链接](https://zhidao.baidu.com/question/427095565.html)

- *语法*

```
lea <mem, <reg32
```

- *例子*

```
lea (%ebx,%esi,8), %edi ;EBX+8*ESI 的值被移入到了 EDIlea val(,1), %eax ;val 的值被移入到了 EAX
```

#### 3.3.4.2 逻辑运算指令

- `add` 整数相加

`add` 指令将两个参数相加, 然后将结果存放到第二个参数中. 注意, 参数可以是寄存器,但参数中最多只有一个内存单元. 这话有点绕, 我们直接看语法 :

- *语法*

```
add <reg, <regadd <mem, <regadd <reg, <memadd <con, <regadd <con, <mem
```

- *例子*

```
add $10, %eax ;EAX 中的值被设置为了 EAX+10.addb $10, (%eax) ;往 EAX 中的值 所代表的内存单元地址 加上 1 个字节的数字 10.
```

- `sub` 整数相减

`sub`指令将第二个参数的值与第一个相减, 就是后面那个减去前面那个, 然后把结果存储到第二个参数. 和`add`一样, 两个参数都可以是寄存器, 但两个参数中最多只能有一个是内存单元.

- *语法*

```
sub <reg, <regsub <mem, <regsub <con, <regsub <con, <mem
```

- *例子*

```
sub %ah, %al ;AL 被设置成 AL-AHsub $216, %eax ;将 EAX 中的值减去 216
```

- `inc, dec` 自增, 自减

`inc` 指令让它的参数加 1, `dec` 指令则是让它的参数减去 1.

- *语法*

```
inc <reginc <memdec <regdec <mem
```

- *例子*

```
dec %eax ;EAX 中的值减去 1incl var(,1) ;将 var 所代表的 32 位整数加上 1.
```

- `imul` 整数相乘

`imul` 指令有两种基本格式 : 第一种是 2 个参数的 ( 看下面语法开始两条 ); 第二种格式是 3 个参数的 ( 看下面语法最后两条 ).

2 个参数的这种格式, 先是将两个参数相乘, 然后把结果存到第二个参数中. 运算结果 ( 即第二个参数 ) 必须是一个寄存器.

3 个参数的这种格式, 先是将它的第 1 个参数和第 2 个参数相乘, 然后把结果存到第 3 个参数中, 当然, 第 3 个参数必须是一个寄存器. 此外, 第 1 个参数必须是一个常数.

- *语法*

```
imul <reg32, <reg32imul <mem, <reg32imul <con, <reg32, <reg32imul <con, <mem, <reg32
```

- *例子*

```
imul (%ebx), %eax ;将 EAX 中的 32 位整数, 与 EBX 中的内容所指的内存单元, 相乘, 然后把结果存到 EAX 中.imul $25, %edi, %esi ;ESI 被设置为 EDI * 25.
```

- `idiv` 整数相除

`idiv`只有一个操作数，此操作数为除数，而被除数则为 EDX : EAX 中的内容（一个64位的整数）， 除法结果 ( 商 ) 存在 EAX 中, 而所得的余数存在 EDX 中.

- *语法*

```
idiv <reg32idiv <mem
```

- *例子*

```
idiv %ebx ;用 EDX : EAX 的值除以 EBX 的值. 商存放在 EAX 中, 余数存放在 EDX 中.idivw (%ebx) ;将 EDX : EAX 的值除以存储在 EBX 所对应内存单元的 32 位值. 商存放在 EAX 中, 余数存放在 EDX 中.
```

- `and, or, xor` 按位逻辑 与, 或, 异或 运算

这些指令分别对它们的参数进行相应的逻辑运算, 运算结果存到第一个参数中.

- *语法*

```
and <reg, <regand <mem, <regand <reg, <memand <con, <regand <con, <memor <reg, <regor <mem, <regor <reg, <memor <con, <regor <con, <memxor <reg, <regxor <mem, <regxor <reg, <memxor <con, <regxor <con, <mem
```

- *例子*

```
and $0x0F, %eax ;只留下 EAX 中最后 4 位数字 (二进制位)xor %edx, %edx ;将 EDX 的值全部设置成 0
```

- `not` 逻辑位运算 非

对参数进行逻辑非运算, 即翻转参数中所有位的值.

- *语法*

```
not <regnot <mem
```

- *例子*

```
not %eax ;将 EAX 的所有值翻转.
```

- `neg` 取负指令

取参数的二进制补码负数. 直接看例子也许会更好懂.

- *语法*

```
neg <regneg <mem
```

- *例子*

```
neg %eax ;EAX → -EAX
```

- `shl, shr` 按位左移或者右移

这两个指令对第一个参数进行位运算, 移动的位数由第二个参数决定, 移动过后的空位拿 0 补上.被移的参数最多可以被移 31 位. 第二个参数可以是 8 位常数或者寄存器 CL. 在任意情况下, 大于 31 的移位都默认是与 32 取模.

- *语法*

```
shl <con8, <regshl <con8, <memshl %cl, <regshl %cl, <memshr <con8, <regshr <con8, <memshr %cl, <regshr %cl, <mem
```

- *例子*

```
shl $1, %eax ;将 EAX 的值乘以 2 (如果最高有效位是 0 的话)shr %cl, %ebx ;将 EBX 的值除以 2n, 其中 n 为 CL 中的值, 运算最终结果存到 EBX 中.
你也许会想, 明明只是把数字二进制移了 1 位, 结果却是等于这个数字乘以 2.什么情况 ? 这几个位运算的结果和计算机表示数字的原理有关,请看本章附录的计算机数字表示.
```

#### 3.3.4.3 流程控制指令

x86 处理器有一个指令指针寄存器 ( EIP ), 该寄存器为 32 位寄存器, 它用来在内存中指示我们输入汇编指令的位置. 就是说这个寄存器指向哪个内存单元, 那个单元存储的机器码就是程序执行的指令. 通常它是指向我们程序要执行的 下一条指令. 但是你不能直接操作 EIP 寄存器, 你需要流程控制指令来隐式地给它赋值.

我们使用符号 `<label` 来当作程序中的标签. 通过输入标签名称后跟冒号, 可以将标签插入 x86 汇编代码文本中的任何位置. 例如 :

```
       mov 8(%ebp), %esibegin:       xor %ecx, %ecx       mov (%esi), %eax
```

该代码片段中的第二段被套上了 “ begin “ 这个标签. 在代码的其它地方, 我们可以用 “ begin “ 这个标签从而更方便地来引用这段指令在内存中的位置. 这个标签只是用来更方便地表示位置的, 它并不是用来代表某个 32 位值.

- `jmp` 跳转指令

  将程序跳转到参数指定的内存地址, 然后执行该内存地址的指令.

- *语法*

```
jmp <label
```

- *例子*

```
jmp begin ;跳转到打了 " begin " 这个标签的地方
```

![jmp](https://static.sitestack.cn/projects/CTF-All-In-One/ac978389a4f48a02c8a8fe6f11558085.png)

- `jcondition` 有条件的跳转

这些指令是条件跳转指令, 它们基于一组条件代码的状态, 这些条件代码的状态存放在称为机器状态字 ( machine status word ) 的特殊寄存器中. 机器状态字的内容包括关于最后执行的算术运算的信息. 例如, 这个字的一个位表示最后的结果是否为 0. 另一个位表示最后结果是否为负数. 基于这些条件代码, 可以执行许多条件跳转. 例如, 如果最后一次算术运算结果为 0, 则 `jz` 指令就是跳转到指定参数标签. 否则, 程序就按照流程进入下一条指令.

许多条件分支的名称都是很直观的, 这些指令的运行, 都和一个特殊的比较指令有关, `cmp`( 见下文 ). 例如, 像 `jle` 和 `jne` 这种指令, 它们首先对参数进行 `cmp` 操作.

- *语法*

```
je <label ;当相等的时候跳转jne <label ;当不相等的时候跳转jz <label ;当最后结果为 0 的时候跳转jg <label ;当大于的时候跳转jge <label ;当大于等于的时候跳转jl <label ;当小于的时候跳转jle <label ;当小于等于的时候跳转
```

- *例子*

```
cmp %ebx, %eaxjle done;如果 EAX 的值小于等于 EBX 的值, 就跳转到 " done " 标签, 否则就继续执行下一条指令.
```

![jcondition](https://static.sitestack.cn/projects/CTF-All-In-One/dd6c24a5d4e8b9398103bbd5e80cde5e.png)

- `cmp` 比较指令

比较两个参数的值, 适当地设置机器状态字中的条件代码. 此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中.

- *语法*

```
cmp <reg, <regcmp <mem, <regcmp <reg, <memcmp <con, <reg
```

- *例子*

```
cmpb $10, (%ebx)jeq loop;如果 EBX 的值等于整数常量 10, 则跳转到标签 " loop " 的位置.
```

![cmp](https://static.sitestack.cn/projects/CTF-All-In-One/d8f143585861afcf50c2e309343b0b04.png)

- `call, ret` 子程序调用与返回

这两个指令实现子程序的调用和返回. `call` 指令首先将当前代码位置推到内存中硬件支持的栈内存上 ( 请看 `push` 指令 ), 然后无条件跳转到标签参数指定的代码位置. 与简单的 `jmp` 指令不同, `call` 指令保存了子程序完成时返回的位置. 就是 `call` 指令结束后, 返回到调用之前的地址.

`ret` 指令实现子程序的返回. 该指令首先从栈中取出代码 ( 类似于 `pop` 指令 ). 然后它无条件跳转到检索到的代码位置.

- *语法*

```
call <labelret
```

### 3.3.5 调用约定 Calling Convention

为了方便不同的程序员去分享代码和运行库, 并简化一般子程序的使用, 程序员们通常会遵守一定的约定 ( Calling Convention ). 调用约定是关于如何从例程调用和返回的协议. 例如，给定一组调用约定规则，程序员不需要检查子例程的定义来确定如何将参数传递给该子例程. 此外，给定一组调用约定规则，可以使高级语言编译器遵循规则，从而允许手动编码的汇编语言例程和高级语言例程相互调用.

我们将讲解被广泛使用的 C 语言调用约定. 遵循此约定将允许您编写可从 C ( 和C ++ ) 代码安全地调用的汇编语言子例程, 并且还允许您从汇编语言代码调用 C 函数库.

C 调用约定很大程度上取决于使用硬件支持的栈内存. 它基于 `push`, `pop`, `call` 和 `ret` 指令. 子程序的参数在栈上传递. 寄存器保存在栈中, 子程序使用的局部变量放在栈中. 在大多数处理器上实现的高级过程语言都使用了类似的调用约定.

调用约定分为两组. 第一组规则是面向子例程的调用者 ( Caller ) 的, 第二组规则面向子例程的编写者, 即被调用者 ( Callee ). 应该强调的是, 错误地遵守这些规则会导致程序的致命错误, 因为栈将处于不一致的状态; 因此, 在你自己的子例程中实现调用约定的时候, 务必当心.

![stack-convention](https://static.sitestack.cn/projects/CTF-All-In-One/67fc3a6b8ff27865395f218be13ec3ca.png)

将调用约定可视化的一种好方法是, 在子例程执行期间画一个栈内存附近的图. 图 2 描绘了在执行具有三个参数和三个局部变量的子程序期间栈的内容. 栈中描绘的单元都是 32 位内存单元, 因此这些单元的内存地址相隔 4 个字节. 第一个参数位于距基指针 8 个字节的偏移处. 在栈参数的上方 ( 和基指针下方 ), `call` 指令在这放了返回地址, 从而导致从基指针到第一个参数有额外 4 个字节的偏移量. 当 `ret` 指令用于从子程序返回时, 它将跳转到栈中的返回地址.

#### 3.3.5.1 调用者约定 Caller Rules

要进行子程序调用, 调用者应该 :

1. 在调用子例程之前, 调用者应该保存指定调用者保存 ( Caller-saved )的某些寄存器的内容. 调用者保存的寄存器是 EAX, ECX, EDX. 由于被调用的子程序可以修改这些寄存器, 所以如果调用者在子例程返回后依赖这些寄存器的值, 调用者必须将这些寄存器的值入栈, 然后就可以在子例程返回后恢复它们.
2. 要把参数传递给子例程, 你可以在调用之前把参数入栈. 参数的入栈顺序应该是反着的, 就是最后一个参数应该最先入栈. 随着栈内存地址增大, 第一个参数将存储在最低的地址, 在历史上, 这种参数的反转用于允许函数传递可变数量的参数.
3. 要调用子例程, 请使用`call`指令. 该指令将返回地址存到栈上, 并跳转到子程序的代码. 这个会调用子程序, 这个子程序应该遵循下面的被调用者约定.

子程序返回后 ( 紧跟调用指令后 ), 调用者可以期望在寄存器 EAX 中找到子例程的返回值. 要恢复机器状态 ( machine state ), 调用者应该 :

1. 从栈中删除参数, 这会把栈恢复到调用之前的状态.
2. 把 EAX, ECX, EDX 之前入栈的内容给出栈, 调用者可以假设子例程没有修改其它寄存器.

- **例子**

下面的代码就是个活生生的例子, 它展示了遵循约定的函数调用. 调用者正在调用一个带有 3 个整数参数的函数 myFunc. 第一个参数是 EAX, 第二个参数是常数 216; 第三个参数位于 EBX 的值所代表的内存地址.

```
push (%ebx) ;最后一个参数最先入栈push $216 ;把第二个参数入栈push %eax ;第一个参数最后入栈call myFunc ;调用这个函数 ( 假设以 C 语言的模式命名 )add $12, %esp
```

注意, 在调用返回后, 调用者使用 `add` 指令来清理栈内存. 我们栈内存中有 12 个字节 ( 3 个参数, 每个参数 4 个字节 ), 然后栈内存地址增大. 因此, 为了摆脱掉这些参数, 我们可以直接往栈里面加个 12.

myFunc 生成的结果现在可以有用于寄存器 EAX. 调用者保存 ( Caller-saved ) 的寄存器 ( ECX, EDX ) 的值可能已经被修改. 如果调用者在调用之后使用它们，则需要在调用之前将它们保存在堆栈中并在调用之后恢复它们. 说白了就是把栈这个玩意当作临时存放点.

#### 3.3.5.2 被调用者约定 Callee Rules

子例程的定义应该遵循子例程开头的以下规则 :

- 1.将 EBP 的值入栈, 然后用下面的指示信息把 ESP 的值复制到 EBP 中 :

```
 push %ebp mov  %esp, %ebp
```

这个初始操作保留了基指针 EBP. 按照约定, 基指针作为栈上找到参数和变量的参考点. 当子程序正在执行的时候, 基指针保存了从子程序开始执行是的栈指针值的副本. 参数和局部变量将始终位于远离基指针值的已知常量偏移处. 我们在子例程的开头推送旧的基指针值，以便稍后在子例程返回时为调用者恢复适当的基指针值. 记住, 调用者不希望子例程修改基指针的值. 然后我们把栈指针移动到 EBP 中, 以获取访问参数和局部变量的参考点.

- 2.接下来, 通过在栈中创建空间来分配局部变量. 回想一下, 栈会向下增长, 因此要在栈顶部创建空间, 栈指针应该递减. 栈指针递减的数量取决于所需局部变量的数量和大小. 例如, 如果需要 3 个局部整数 ( 每个 4 字节 ), 则需要将堆栈指针递减 12, 从而为这些局部变量腾出空间 ( 即sub $12, %esp ). 和参数一样, 局部变量将位于基指针的已知偏移处.
- 3.接下来, 保存将由函数使用的 被调用者保存的 ( Callee-saved ) 寄存器的值. 要存储寄存器, 请把它们入栈. 被调用者保存 ( Callee-saved ) 的寄存器是 EBX, EDI 和 ESI ( ESP 和 EBP 也将由调用约定保留, 但在这个步骤中不需要入栈 ).

在完成这 3 步之后, 子例程的主体可以继续. 返回子例程的时候, 必须遵循以下步骤 :

1. 将返回值保存在 EAX 中.
2. 恢复已经被修改的任何被调用者保存 ( Callee-saved ) 的寄存器 ( EDI 和 ESI ) 的旧值. 通过出栈来恢复它们. 当然应该按照相反的顺序把它们出栈.
3. 释放局部变量. 显而易见的法子是把相应的值添加到栈指针 ( 因为空间是通过栈指针减去所需的数量来分配的 ). 事实上呢, 解除变量释放的错误的方法是将基指针中的值移动到栈指针 : `mov %ebp, %esp`. 这个法子有效, 是因为基指针始终包含栈指针在分配局部变量之前包含的值.
4. 在返回之前, 立即通过把 EBP 出栈来恢复调用者的基指针值. 回想一下, 我们在进入子程序的时候做的第一件事是推动基指针保存它的旧值.
5. 最后, 通过执行 `ret` 指令返回. 这个指令将从栈中找到并删除相应的返回地址 ( call 指令保存的那个 ).

请注意, 被调用者的约定完全被分成了两半, 简直是彼此的镜像. 约定的前半部分适用于函数开头, 并且通常被称为定义函数的*序言* ( *prologue* ) .这个约定的后半部分适用于函数结尾, 因此通常被称为定义函数的*结尾* ( epilogue ).

- **例子**

这是一个遵循被调用者约定的例子 :

```
;启动代码部分.text;将 myFunc 定义为全局 ( 导出 ) 函数.globl myFunc.type myFunc, @functionmyFunc :;子程序序言push %ebp ;保存基指针旧值mov %esp, %ebp ;设置基指针新值sub $4, %esp ;为一个 4 字节的变量腾出位置push %edipush %esi ;这个函数会修改 EDI 和 ESI, 所以先给它们入栈;不需要保存 EBX, EBP 和 ESP;子程序主体mov 8(%ebp), %eax ;把参数 1 的值移到 EAX 中mov 12(%ebp), %esi ;把参数 2 的值移到 ESI 中mov 16(%ebp), %edi ;把参数 3 的值移到 EDI 中mov %edi, -4(%ebp) ;把 EDI 移给局部变量add %esi, -4(%ebp) ;把 ESI 添加给局部变量add -4(%ebp), %eax ;将局部变量的内容添加到 EAX ( 最终结果 ) 中;子程序结尾pop %esi ;恢复寄存器的值pop %edimov %ebp, %esp ;释放局部变量pop %ebp ;恢复调用者的基指针值ret
```

子程序序言执行标准操作, 即在 EBP ( 基指针 ) 中保存栈指针的副本, 通过递减栈指针来分配局部变量, 并在栈上保存寄存器的值.

在子例程的主体中, 我们可以看到基指针的使用. 在子程序执行期间, 参数和局部变量都位于与基指针的常量偏移处. 特别地, 我们注意到, 由于参数在调用子程序之前被放在栈中, 因此它们总是位于栈基指针 ( 即更高的地址 ) 之下. 子程序的第一个参数总是可以在内存地址 ( EBP+8 ) 找到, 第二个参数在 ( EBP+12 ), 第三个参数在 ( EBP+16). 类似地, 由于在设置基指针后分配局部变量, 因此它们总是位于栈上基指针 ( 即较低地址 ) 之上. 特别是, 第一个局部变量总是位于 ( EBP-4 ), 第二个位于 ( EBP-8 ), 以此类推. 这种基指针的常规使用, 让我们可以快速识别函数内部局部变量和参数的使用.

函数结尾基本上是函数序言的镜像. 从栈中恢复调用者的寄存器值, 通过重置栈指针来释放局部变量, 恢复调用者的基指针值, 并用 `ret` 指令返回调用者中的相应代码位置, 从哪来回哪去.

[维基百科 X86 调用约定](https://zh.wikipedia.org/wiki/X86调用约定)

## 3.4 x64 汇编基础

### 3.4.1 导语

x86-64 (也被称为 x64 或者 AMD64) 是 64 位版本的 x86/IA32 指令集. 以下是我们关于 CS107 相关功能的概述.

### 3.4.2 寄存器 Registers

下图列出了常用的寄存器 ( 16个通用寄存器加上 2 个特殊用途寄存器 ). 每个寄存器都是 64 bit 宽, 它们的低 32, 16, 8 位都可以看成相应的 32, 16, 8 位寄存器, 并且都有其特殊名称. 一些寄存器被设计用来完成某些特殊目的, 比如 %rsp 被用来作为栈指针, %rax 作为一个函数的返回值. 其他寄存器则都是通用的, 但是一般在使用的时候, 还是要取决于调用者 ( Caller-owned )或者被调用者 ( Callee-owned ). 如果函数 binky 调用了 winky, 我们称 binky 为调用者, winky 为被调用者. 例如, 用于前 6 个参数和返回值的寄存器都是被调用者所有的 ( Callee-owned ). 被调用者可以任意使用这些寄存器, 不用任何预防措施就可以随意覆盖里面的内容. 如果 `%rax` 存着调用者想要保留的值, 则 Caller 必须在调用之前将这个 `%rax` 的值复制到一个 “ 安全 “ 的位置. 被调用者拥有的 ( Callee-owned ) 寄存器非常适合一些临时性的使用. 相反, 如果被调用者打算使用调用者所拥有的寄存器, 那么被调用者必须首先把这个寄存器的值存起来, 然后在退出调用之前把它恢复. 调用者拥有的 ( Caller-owned ) 寄存器用于保存调用者的本地状态 ( local state ), 所以这个寄存器需要在进一步的函数调用中被保留下来.

------

![img](https://static.sitestack.cn/projects/CTF-All-In-One/c2d4e3f411c83ccd807ca1b1b9c41a7d.png)

------

### 3.4.3 寻址模式 Addressing modes

正由于它的 CISC 特性, X86-64 支持各种寻址模式. 寻址模式是计算要读或写的内存地址的表达式. 这些表达式用作`mov`指令和访问内存的其它指令的来源和去路. 下面的代码演示了如何在每个可用的寻址模式中将 立即数 1 写入各种内存位置 :

```
movl $1, 0x604892         ;直接写入, 内存地址是一个常数movl $1, (%rax)           ;间接写入, 内存地址存在寄存器 %rax 中movl $1, -24(%rbp)       ;使用偏移量的间接写入                         ;公式 : (address = base %rbp + displacement -24)movl $1, 8(%rsp, %rdi, 4) ;间接写入, 用到了偏移量和按比例放大的索引 ( scaled-index )           ;公式 : (address = base %rsp + displ 8 + index %rdi * scale 4)movl $1, (%rax, %rcx, 8) ;特殊情况, 用到了按比例放大的索引 ( scaled-index ), 假设偏移量 ( displacement ) 为 0movl $1, 0x8(, %rdx, 4)  ;特殊情况, 用到了按比例放大的索引 ( scaled-index ), 假设基数 ( base ) 为 0movl $1, 0x4(%rax, %rcx) ;特殊情况, 用到了按比例放大的索引 ( scaled-index ), 假设比例 ( scale ) 为0
```

### 3.4.4 通用指令 Common instructions

先说下指令后缀, 之前讲过这里就重温一遍 : 许多指令都有个后缀 ( b, w, l, q ) , 后缀指明了这个指令代码所操纵参数数据的位宽 ( 分别为 1, 2, 4 或 8 个字节 ). 当然, 如果可以从参数确定位宽的时候, 后缀可以被省略. 例如呢, 如果目标寄存器是 %eax, 则它必须是 4 字节宽, 如果是 %ax 寄存器, 则必须是 2 个字节, 而 %al 将是 1 个字节. 还有些指令, 比如 `movs` 和 `movz` 有两个后缀 : 第一个是来源参数, 第二个是去路. 这话乍一看让人摸不着头脑, 且听我分析. 例如, `movzbl` 这个指令把 1 个字节的来源参数值移动到 4 个字节的去路.

当目标是子寄存器 ( sub-registers ) 时, 只有子寄存器的特定字节被写入, 但有一个例外 : 32 位指令将目标寄存器的高 32 位设置为 0.

#### `mov` 和 `lea` 指令

到目前为止, 我们遇到的最频繁的指令就是 `mov`, 而它有很多变种. 关于 `mov` 指令就不多说了, 和之前 32 位 x86 的没什么区别. `lea` 指令其实也没什么好说的, 上一节都有, 这里就不废话了.

```
这里写几个比较有意思的例子 :mov 8(%rsp), %eax    ;%eax = 从地址 %rsp + 8 读取的值lea 0x20(%rsp), %rdi ;%rdi = %rsp + 0x20lea (%rdi,%rdx,1), %rax  ;%rax = %rdi + %rdx
```

在把较小位宽的数据移动复制到较大位宽的情况下, `movs` 和 `movz` 这两个变种指令用于指定怎么样去填充字节, 因为你是一个小东西被移到了一个大空间, 肯定还有地方是空的, 所以空的地方要填起来, 拿 0 或者 符号扩展 ( sign-extend ) 来填充.

```
movsbl %al, %edx     ;把 1 个字节的 %al, 符号扩展 复制到 4 字节的 %edxmovzbl %al, %edx     ;把 1 个字节的 %al, 零扩展 ( zero-extend ) 复制到 4 字节的 %edx
```

有个特殊情况要注意, 默认情况下, 将 32 位值写入寄存器的 `mov` 指令, 也会将寄存器的高 32 位归零, 即隐式零扩展到位宽 q. 这个解释了诸如 `mov %ebx, %ebx` 这种指令, 这些指令看起来很奇怪, 但实际上这是用于从 32 位扩展到 64 位. 因为这个是默认的, 所以我们不用显式的 `movzlq` 指令. 当然, 有一个 `movslq` 指令也是从 32 位符号扩展到 64 位.

`cltq` 指令是一个在 %rax 上运行的专用移动指令. 这个没有参数的指令在 %rax 上进行符号扩展, 源位宽为 L, 目标位宽为 q.

```
cltq   ;在 ％rax 上运行，将 4 字节 src 符号扩展为 8 字节 dst，用于 movslq ％eax，％rax
```

#### 算术和位运算

二进制的运算一般是两个参数, 其中第二个参数既是我们指令运算的来源, 也是去路的来源, 就是说我们把运算结果存在第二个参数里. 我们的第一个参数可以是立即数常数, 寄存器或者内存单元. 第二个参数必须是寄存器或者内存. 这两个参数中, 最多只有一个参数是内存单元, 当然也有的指令只有一个参数, 这个参数既是我们运算数据的来源, 也是我们运算数据的去路, 它可以是寄存器或者内存. 这个我们上一节讲了, 这里回顾一下. 许多算术指令用于有符号和无符号类型,也就是带符号加法和无符号加法都使用相同的指令. 当需要的时候, 参数设置的条件代码可以用来检测不同类型的溢出.

```
add src, dst ;dst = dst + srcsub src, dst ;dst = dst - srcimul src, dst ;dst = dst * srcneg dst ;dst = -dst ( 算术取反 )and src, dst ;dst = dst & srcor src, dst ;dst = dst | srcxor src, dst ;dst = dst ^ srcnot dst ;dst = ~dst ( 按位取反 )shl count, dst ;dst <<= count ( 按 count 的值来左移 ), 跟这个相同的是`sal`指令sar count, dst ;dst = count ( 按 count 的值来算术右移 )shr count, dst ;dst = count ( 按 count 的值来逻辑右移 );某些指令有特殊情况变体, 这些变体有不同的参数imul src ;一个参数的 imul 指令假定 %rax 中其他参数计算 128 位的结果, 在 %rdx 中存储高 64 位, 在 %rax 中存储低 64 位.shl dst ;dst <<= 1 ( 后面没有 count 参数的时候默认是移动 1 位, `sar`, `shr`, `sal` 指令也是一样 )
```

这些指令上一节都讲过, 这里稍微提一下.

#### 流程控制指令

有一个特殊的 %eflags 寄存器, 它存着一组被称为条件代码的布尔标志. 大多数的算术运算会更新这些条件代码. 条件跳转指令读取这些条件代码之后, 再确定是否执行相应的分支指令. 条件代码包括 ZF( 零标志 ), SF( 符号标志 ), OF( 溢出标志, 有符号 ) 和 CF( 进位标志, 无符号 ). 例如, 如果结果为 0 , 则设置 ZF, 如果操作溢出 ( 进入符号位 ), 则设置 OF.

这些指令一般是先执行 `cmp` 或 `test` 操作来设置标志, 然后再跟跳转指令变量, 该变量读取标志来确定是采用分支代码还是继续下一条代码. `cmp` 或 `test` 的参数是立即数, 寄存器或者内存单元 ( 最多只有一个内存参数 ). 条件跳转有 32 中变体, 其中几种效果是一样的. 下面是一些分支指令.

```
cmpl op2, op1 ;运算结果 = op1 - op2, 丢弃结果然后设置条件代码test op2, op1 ;运算结果 = op1 & op2, 丢弃结果然后设置条件代码jmp target ;无条件跳跃je target ;等于时跳跃, 和它相同的还有 jz, 即jump zero ( ZF = 1 )jne target ;不相等时跳跃, 和它相同的还有 jnz, 即 jump non zero ( ZF = 0 )jl target ;小于时跳跃, 和它相同的还有 jnge, 即 jump not greater or equal ( SF != OF )  jle target ;小于等于时跳跃, 和它相同的还有 jng, 即 jump not greater ( ZF = 1 or SF != OF )jg target ;大于时跳跃, 和它相同的还有 jnle, 即 jump not less or equal ( ZF = 0 and SF = OF )jge target ;大于等于时跳跃, 和它相同的还有 jnl, 即 jump not less ( SF = OF )ja  target ;跳到上面, 和它相同的还有 jnbe, 即 jump not below or equal ( CF = 0 and ZF = 0 )jb  target ;跳到下面, 和它相同的还有 jnae, 即 jump not above or equal ( CF = 1 )js  target ;SF = 1 时跳跃jns target ;SF = 0 时跳跃
```

其实你也会发现这里大部分上一节都讲过, 这里我们可以再来一遍巩固一下.

#### `setx`和`movx`

还有两个指令家族可以 读取/响应 当前的条件代码. `setx` 指令根据条件 x 的状态将目标寄存器设置为 0 或 1. `cmovx` 指令根据条件 x 是否成立来有条件地执行 mov. x 是任何条件变量的占位符, 就是说 x 可以用这些来代替 : e, ne, s, ns. 它们的意思上面也都说过了.

```
sete dst ;根据 零/相等( zero/equal ) 条件来把 dst 设置成 0 或 1setge dst ;根据 大于/相等( greater/equal ) 条件来把 dst 设置成 0 或 1cmovns src, dst ;如果 ns 条件成立, 则继续执行 movcmovle src, dst ;如果 le 条件成立, 则继续执行 mov
```

对于 `setx` 指令, 其目标必须是单字节寄存器 ( 例如 %al 用于 %rax 的低字节 ). 对于 `cmovx` 指令, 其来源和去路都必须是寄存器.

#### 函数调用与栈

%rsp 寄存器用作 “ 栈指针 “; `push` 和 `pop` 用于添加或者删除栈内存中的值. `push` 指令只有一个参数, 这个参数是立即数常数, 寄存器或内存单元. `push` 指令先把 %rsp 的值递减, 然后将参数复制到栈内存上的 tompost. `pop` 指令也只有一个参数, 即目标寄存器. `pop` 先把栈内存最顶层的值复制到目标寄存器, 然后把 %rsp 递增. 直接调整 %rsp, 以通过单个参数添加或删除整个数组或变量集合也是可以的. 但注意, 栈内存是朝下增长 ( 即朝向较低地址 ).

```
push %rbx ;把 %rbx 入栈pushq $0x3 ;把立即数 3 入栈sub $0x10, %rsp ;调整栈指针以空出 16 字节pop %rax ;把栈中最顶层的值出栈到寄存器 %rax 中add $0x10, %rsp ;调整栈指针以删除最顶层的 16 个字节
```

函数之间是通过互相调用返回来互相控制的. `callq` 指令有一个参数, 即被调用的函数的地址. 它将返回来的地址入栈, 这个返回来的地址即 %rip 当前的值, 也即是调用函数后的下一条指令. 然后这个指令让程序跳转到被调用的函数的地址. `retq` 指令把刚才入栈的地址给出栈, 让它回到 %rip 中, 从而让程序在保存的返回地址处重新开始, 就是说你中途跳到别的地方去, 你回来的时候要从你跳的那个地方重新开始.

当然, 你如果要设置这种函数间的互相调用, 调用者需要将前六个参数放入寄存器 %rdi, %rsi, %rdx, %rcx, %r8 和 %r9 ( 任何其它参数都入栈 ), 然后再执行调用指令.

```
mov $0x3, %rdi ;第一个参数在 %rdi 中mov $0x7, %rsi ;第二个参数在 %rsi 中callq binky ;把程序交给 binky 控制
```

当被调用者那个函数完事的时候, 这个函数将返回值 ( 如果有的话 ) 写入 %rax, 然后清理栈内存, 并使用 `retq` 指令把程序控制权交还给调用者.

```
mov $0x0, %eax ;将返回值写入 %raxadd $0x10, %rsp ;清理栈内存retq ;交还控制权, 跳回去
```

这些分支跳转指令的目标通常是在编译时确定的绝对地址. 但是, 有些情况下直到运行程序的时候, 我们才知道目标的绝对内存地址. 例如编译为跳转表的 switch 语句或调用函数指针时. 对于这些, 我们先计算目标地址, 然后把地址存到寄存器中, 然后用 分支/调用( branch/call ) 变量 `je *%rax` 或 `callq *%rax` 从指定寄存器中读取目标地址.

当然还有更简单的方法, 就是上一节讲的打标签.

### 3.4.5 汇编和 gdb

调试器 ( debugger ) 有许多功能, 这可以让你可以在程序中追踪和调试代码. 你可以通过在其名称上加个 $ 来打印寄存器中的值, 或者使用命令 info reg 转储所有寄存器的值 :

```
(gdb) p $rsp(gdb) info reg
```

`disassemble` 命令按照名称打印函数的反汇编. `x` 命令支持 i 格式, 这个格式把内存地址的内容解释为编码指令 ( 解码 ).

```
(gdb) disassemble main //反汇编, 然后打印所有 main 函数的指令(gdb) x/8i main //反汇编, 然后打印开始的 8 条指令
```

你可以通过在函数中的直接地址或偏移量为特定汇编指令设置断点.

```
(gdb) b *0x08048375(gdb) b *main+7 //在 main+7个字节这里设置断点
```

你可以用 `stepi` 和 `nexti` 命令来让程序通过指令 ( 而不是源代码 ) 往前执行.

```
(gdb) stepi(gdb) nexti
```

## 3.5 ARM汇编基础

### 3.5.1 引言

本章所讲述的是在 GNU 汇编程序下的 ARM 汇编快速指南，而所有的代码示例都会采用下面的结构：

```
[< 标签 label :]  {<指令 instruction or directive } @ 注释 comment
```

在 GNU 程序中不需要缩进指令。程序的标签是由冒号识别而与所处的位置无关。 就通过一个简单的程序来介绍：

```
.section .text, "x".global   add @给符号添加外部链接add:       ADD    r0, r0, r1    @添加输入参数      MOV    pc, lr         @从子程序返回                            @程序结束
```

它定义的是一个返回总和函数 “ add ”，允许两个输入参数。通过了解这个程序实例，想必接下来这类程序的理解我们也能够很好的的掌握。

### 3.5.2 ARM 的 GNU 汇编程序指令表

在 GNU 汇编程序下的 ARM 指令集涵括如下：

| GUN 汇编程序指令                                        | 描述                                                         |
| :------------------------------------------------------ | :----------------------------------------------------------- |
| `.ascii "<string>"`                                     | 将字符串作为数据插入到程序中                                 |
| `.asciz "<string>"`                                     | 与 .ascii 类似，但跟随字符串的零字节                         |
| `.balign <power_of_2> {,<fill_value>{,<max_padding>} }` | 将地址与 `<power_of_2>` 字节对齐。 汇编程序通过添加值 `<fill_value>` 的字节或合适的默认值来对齐. 如果需要超过 `<max_padding>` 这个数字来填充字节，则不会发生对齐（ 类似于armasm 中的 ALIGN ） |
| `.byte <byte1> {,<byte2> } …`                           | 将一个字节值列表作为数据插入到程序中                         |
| `.code <number_of_bits>`                                | 以位为单位设置指令宽度。 使用 16 表示 Thumb，32 表示 ARM 程序（ 类似于 armasm 中的 CODE16 和 CODE32 ） |
| `.else`                                                 | 与.if和 .endif 一起使用（ 类似于 armasm 中的 ELSE ）         |
| `.end`                                                  | 标记程序文件的结尾（ 通常省略 ）                             |
| `.endif`                                                | 结束条件编译代码块 - 参见.if，.ifdef，.ifndef（ 类似于 armasm 中的 ENDIF ） |
| `.endm`                                                 | 结束宏定义 - 请参阅 .macro（ 类似于 armasm 中的 MEND ）      |
| `.endr`                                                 | 结束重复循环 - 参见 .rept 和 .irp（类似于 armasm 中的 WEND ） |
| `.equ <symbol name>, <vallue>`                          | 该指令设置符号的值（ 类似于 armasm 中的 EQU ）               |
| `.err`                                                  | 这个会导致程序停止并出现错误                                 |
| `.exitm`                                                | 中途退出一个宏 - 参见 .macro（ 类似于 armasm 中的 MEXIT ）   |
| `.global <symbol>`                                      | 该指令给出符号外部链接（ 类似于 armasm 中的 MEXIT ）。       |
| `.hword <short1> {,<short2> }...`                       | 将16位值列表作为数据插入到程序中（ 类似于 armasm 中的 DCW ） |
| `.if <logical_expression>`                              | 把一段代码变成前提条件。 使用 .endif 结束代码块（ 类似于 armasm中的 IF ）。 另见 .else |
| `.ifdef <symbol>`                                       | 如果定义了 `<symbol>`，则包含一段代码。 结束代码块用 .endif, 这就是个条件判断嘛, 很简单的. |
| `.ifndef <symbol>`                                      | 如果未定义 `<symbol>`，则包含一段代码。 结束代码块用 .endif, 同上. |
| `.include "<filename>"`                                 | 包括指定的源文件, 类似于 armasm 中的 INCLUDE 或 C 中的#include |
| `.irp <param> {,<val 1>} {,<val_2>} ...`                | 为值列表中的每个值重复一次代码块。 使用 .endr 指令标记块的结尾。 在里面重复代码块，使用 `\<param>` 替换关联的代码块值列表中的值。 |
| `.macro <name> {<arg_1>} {,< arg_2>} ... {,<arg_N>}`    | 使用 N 个参数定义名为`<name>`的汇编程序宏。宏定义必须以 `.endm` 结尾。 要在较早的时候从宏中逃脱，请使用 `.exitm`。 这些指令是类似于 armasm 中的 MACRO，MEND 和MEXIT。 你必须在虚拟宏参数前面加 `\`. |
| `.rept <number_of_times>`                               | 重复给定次数的代码块。 以`.endr`结束。                       |
| `<register_name> .req <register_name>`                  | 该指令命名一个寄存器。 它与 armasm 中的 `RN` 指令类似，不同之处在于您必须在右侧提供名称而不是数字（例如，`acc .req r0`） |
| `.section <section_name> {,"<flags> "}`                 | 启动新的代码或数据部分。 GNU 中有这些部分:`.text`代码部分;`.data`初始化数据部分和`.bss`未初始化数据部分。 这些部分有默认值flags和链接器理解默认名称（与armasm指令AREA类似的指令）。 以下是 ELF 格式文件允许的 .section标志：a 表示 allowable sectionw 表示 writable sectionx 表示 executable section |
| `.set <variable_name>, <variable_value>`                | 该指令设置变量的值。 它类似于 SETA。                         |
| `.space <number_of_bytes> {,<fill_byte> }`              | 保留给定的字节数。 如果指定了字节，则填充零或 `<fill_byte>`（类似于 armasm 中的 SPACE） |
| `.word <word1> {,<word2>}...`                           | 将 32 位字值列表作为数据插入到程序集中（类似于 armasm 中的 DCD）。 |

### 3.5.3 寄存器名称

通用寄存器：

%r0 - %r15

fp 寄存器：

%f0 - %f7

临时寄存器：

%r0 - %r3, %r12

保存寄存器：

%r4 - %r10

堆栈 ptr 寄存器：

%sp

帧 ptr 寄存器：

%fp

链接寄存器：

%lr

程序计数器：

%ip

状态寄存器：

$psw

状态标志寄存器：

xPSR

xPSR_all

xPSR_f

xPSR_x

xPSR_ctl

xPSR_fs

xPSR_fx

xPSR_fc

xPSR_cs

xPSR_cf

xPSR_cx

### 3.5.4 汇编程序特殊字符/语法

内联评论字符： ‘@’

行评论字符： ‘＃’

语句分隔符： ‘;’

立即操作数前缀： ‘＃’ 或 ‘$’

### 3.5.5 arm程序调用标准

参数寄存器 ：％a0 - ％a4（别名为％r0 - ％r4）

返回值regs ：％v1 - ％v6（别名为％r4 - ％r9）

### 3.5.6 寻址模式

`addr` 绝对寻址模式

`％rn` 寄存器直接寻址

`[％rn]` 寄存器间接寻址或索引

`[％rn，＃n]` 基于寄存器的偏移量

上述 “rn” 指任意寄存器，但不包括控制寄存器。

### 3.5.7 机器相关指令

| 指令               | 描述                                  |
| :----------------- | :------------------------------------ |
| .arm               | 使用arm模式进行装配                   |
| .thumb             | 使用thumb模式进行装配                 |
| .code16            | 使用thumb模式进行装配                 |
| .code32            | 使用arm模式进行组装                   |
| .force_thumb Force | thumb模式（即使不支持）               |
| .thumb_func        | 将输入点标记为thumb编码（强制bx条目） |
| .ltorg             | 启动一个新的文字池                    |





# 内存管理

- [什么是内存](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.7_memory.md#什么是内存)
- [栈与调用约定](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.7_memory.md#栈与调用约定)
- [堆与内存管理](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.7_memory.md#堆与内存管理)

## 什么是内存

为了使用户程序在运行时具有一个私有的地址空间、有自己的 CPU，就像独占了整个计算机一样，现代操作系统提出了虚拟内存的概念。

虚拟内存的主要作用主要为三个：

- 它将内存看做一个存储在磁盘上的地址空间的高速缓存，在内存中只保存活动区域，并根据需要在磁盘和内存之间来回传送数据。
- 它为每个进程提供了一致的地址空间。
- 它保护了每个进程的地址空间不被其他进程破坏。

现代操作系统采用虚拟寻址的方式，CPU 通过生成一个虚拟地址（Virtual Address(VA)）来访问内存，然后这个虚拟地址通过内存管理单元（Memory Management Unit(MMU)）转换成物理地址之后被送到存储器。

![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.7_va.png)

前面我们已经看到可执行文件被映射到了内存中，Linux 为每个进程维持了一个单独的虚拟地址空间，包括了 .text、.data、.bss、栈（stack）、堆（heap），共享库等内容。

32 位系统有 4GB 的地址空间，其中 0x08048000~0xbfffffff 是用户空间（3GB），0xc0000000~0xffffffff 是内核空间（１GB）。

![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.7_vm.png)

## 栈与调用约定

### 栈

栈是一个先入后出（First In Last Out(FIFO)）的容器。用于存放函数返回地址及参数、临时变量和有关上下文的内容。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。

栈由高地址向低地址增长，栈保存了一个函数调用所需要的维护信息，称为堆栈帧（Stack Frame）在 x86 体系中，寄存器 `ebp` 指向堆栈帧的底部，`esp` 指向堆栈帧的顶部。压栈时栈顶地址减小，弹栈时栈顶地址增大。

- `PUSH`：用于压栈。将 `esp` 减 4，然后将其唯一操作数的内容写入到 `esp` 指向的内存地址
- `POP` ：用于弹栈。从 `esp` 指向的内存地址获得数据，将其加载到指令操作数（通常是一个寄存器）中，然后将 `esp` 加 4。

x86 体系下函数的调用总是这样的：

- 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递。
- 把当前指令的下一条指令的地址压入栈中。
- 跳转到函数体执行。

其中第 2 步和第 3 步由指令 `call` 一起执行。跳转到函数体之后即开始执行函数，而 x86 函数体的开头是这样的：

- `push ebp`：把ebp压入栈中（old ebp）。
- `mov ebp, esp`：ebp=esp（这时ebp指向栈顶，而此时栈顶就是old ebp）
- [可选] `sub esp, XXX`：在栈上分配 XXX 字节的临时空间。
- [可选] `push XXX`：保存名为 XXX 的寄存器。

把ebp压入栈中，是为了在函数返回时恢复以前的ebp值，而压入寄存器的值，是为了保持某些寄存器在函数调用前后保存不变。函数返回时的操作与开头正好相反：

- [可选] `pop XXX`：恢复保存的寄存器。
- `mov esp, ebp`：恢复esp同时回收局部变量空间。
- `pop ebp`：恢复保存的ebp的值。
- `ret`：从栈中取得返回地址，并跳转到该位置。

栈帧对应的汇编代码：

```
PUSH ebp        ; 函数开始（使用ebp前先把已有值保存到栈中）MOV ebp, esp    ; 保存当前esp到ebp中...             ; 函数体                ; 无论esp值如何变化，ebp都保持不变，可以安全访问函数的局部变量、参数MOV esp, ebp    ; 将函数的其实地址返回到esp中POP ebp         ; 函数返回前弹出保存在栈中的ebp值RET             ; 函数返回并跳转
```

函数调用后栈的标准布局如下图：

![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.7_stack.png)

我们来看一个例子：[源码](https://www.bookstack.cn/read/CTF-All-In-One/$src-others-1.5.7_memory-stack.c)

```
#include<stdio.h>int add(int a, int b) {    int x = a, y = b;    return (x + y);}int main() {    int a = 1, b = 2;    printf("%d\n", add(a, b));    return 0;}
```

使用 gdb 查看对应的汇编代码，这里我们给出了详细的注释：

```
gdb-peda$ disassemble mainDump of assembler code for function main:   0x00000563 <+0>: lea    ecx,[esp+0x4]                      ;将 esp+0x4 的地址传给 ecx   0x00000567 <+4>: and    esp,0xfffffff0                     ;栈 16 字节对齐   0x0000056a <+7>: push   DWORD PTR [ecx-0x4]                ;ecx-0x4，即原 esp 强制转换为双字数据后压入栈中   0x0000056d <+10>:    push   ebp                              ;保存调用 main() 函数之前的 ebp，由于在 _start 中将 ebp 清零了，这里的 ebp=0x0   0x0000056e <+11>:    mov    ebp,esp                          ;把调用 main() 之前的 esp 作为当前栈帧的 ebp   0x00000570 <+13>:    push   ebx                              ;ebx、ecx 入栈   0x00000571 <+14>:    push   ecx   0x00000572 <+15>:    sub    esp,0x10                         ;为局部变量 a、b 分配空间并做到 16 字节对齐   0x00000575 <+18>:    call   0x440 <__x86.get_pc_thunk.bx>    ;调用 <__x86.get_pc_thunk.bx> 函数，将 esp 强制转换为双字数据后保存到 ebx   0x0000057a <+23>:    add    ebx,0x1a86                       ;ebx+0x1a86   0x00000580 <+29>:    mov    DWORD PTR [ebp-0x10],0x1         ;a 第二个入栈所以保存在 ebp-0x10 的位置，此句即 a=1   0x00000587 <+36>:    mov    DWORD PTR [ebp-0xc],0x2          ;b 第一个入栈所以保存在 ebp-0xc 的位置，此句即 b=2   0x0000058e <+43>:    push   DWORD PTR [ebp-0xc]              ;将 b 压入栈中   0x00000591 <+46>:    push   DWORD PTR [ebp-0x10]             ;将 a 压入栈中   0x00000594 <+49>:    call   0x53d <add>                      ;调用 add() 函数，返回值保存在 eax 中   0x00000599 <+54>:    add    esp,0x8                          ;清理 add() 的参数   0x0000059c <+57>:    sub    esp,0x8                          ;调整 esp 使 16 位对齐   0x0000059f <+60>:    push   eax                              ;eax 入栈   0x000005a0 <+61>:    lea    eax,[ebx-0x19b0]                 ;ebx-0x19b0 的地址保存到 eax，该地址处保存字符串 "%d\n"   0x000005a6 <+67>:    push   eax                              ;eax 入栈   0x000005a7 <+68>:    call   0x3d0 <printf@plt>               ;调用 printf() 函数   0x000005ac <+73>:    add    esp,0x10                         ;调整栈顶指针 esp，清理 printf() 的参数   0x000005af <+76>:    mov    eax,0x0                          ;eax=0x0   0x000005b4 <+81>:    lea    esp,[ebp-0x8]                    ;ebp-0x8 的地址保存到 esp   0x000005b7 <+84>:    pop    ecx                              ;弹栈恢复 ecx、ebx、ebp   0x000005b8 <+85>:    pop    ebx   0x000005b9 <+86>:    pop    ebp   0x000005ba <+87>:    lea    esp,[ecx-0x4]                    ;ecx-0x4 的地址保存到 esp   0x000005bd <+90>:    ret                                     ;返回，相当于 pop eip;End of assembler dump.gdb-peda$ disassemble addDump of assembler code for function add:   0x0000053d <+0>: push   ebp                                ;保存调用 add() 函数之前的 ebp   0x0000053e <+1>: mov    ebp,esp                            ;把调用 add() 之前的 esp 作为当前栈帧的 ebp   0x00000540 <+3>: sub    esp,0x10                           ;为局部变量 x、y 分配空间并做到 16 字节对齐   0x00000543 <+6>: call   0x5be <__x86.get_pc_thunk.ax>      ;调用 <__x86.get_pc_thunk.ax> 函数，将 esp 强制转换为双字数据后保存到 eax   0x00000548 <+11>:    add    eax,0x1ab8                       ;eax+0x1ab8   0x0000054d <+16>:    mov    eax,DWORD PTR [ebp+0x8]          ;将 ebp+0x8 的数据 0x1 传送到 eax，ebp+0x4 为函数返回地址   0x00000550 <+19>:    mov    DWORD PTR [ebp-0x8],eax          ;保存 eax 的值 0x1 到 ebp-0x8 的位置   0x00000553 <+22>:    mov    eax,DWORD PTR [ebp+0xc]          ;将 ebp+0xc 的数据 0x2 传送到 eax   0x00000556 <+25>:    mov    DWORD PTR [ebp-0x4],eax          ;保存 eax 的值 0x2 到 ebp-0x4 的位置   0x00000559 <+28>:    mov    edx,DWORD PTR [ebp-0x8]          ;取出 ebp-0x8 的值 0x1 到 edx   0x0000055c <+31>:    mov    eax,DWORD PTR [ebp-0x4]          ;取出 ebp-0x4 的值 0x2 到 eax   0x0000055f <+34>:    add    eax,edx                          ;eax+edx   0x00000561 <+36>:    leave                                   ;返回，相当于 mov esp,ebp; pop ebp;   0x00000562 <+37>:    retEnd of assembler dump.
```

这里我们在 Linux 环境下，由于 ELF 文件的入口其实是 `_start` 而不是 `main()`，所以我们还应该关注下面的函数：

```
gdb-peda$ disassemble _startDump of assembler code for function _start:   0x00000400 <+0>: xor    ebp,ebp                            ;清零 ebp，表示下面的 main() 函数栈帧中 ebp 保存的上一级 ebp 为 0x00000000   0x00000402 <+2>: pop    esi                                ;将 argc 存入 esi   0x00000403 <+3>: mov    ecx,esp                            ;将栈顶地址（argv 和 env 数组的其实地址）传给 ecx   0x00000405 <+5>: and    esp,0xfffffff0                     ;栈 16 字节对齐   0x00000408 <+8>: push   eax                                ;eax、esp、edx 入栈   0x00000409 <+9>: push   esp   0x0000040a <+10>:    push   edx   0x0000040b <+11>:    call   0x432 <_start+50>                ;先将下一条指令地址 0x00000410 压栈，设置 esp 指向它，再调用 0x00000432 处的指令   0x00000410 <+16>:    add    ebx,0x1bf0                       ;ebx+0x1bf0   0x00000416 <+22>:    lea    eax,[ebx-0x19d0]                 ;取 <__libc_csu_fini> 地址传给 eax，然后压栈   0x0000041c <+28>:    push   eax   0x0000041d <+29>:    lea    eax,[ebx-0x1a30]                 ;取 <__libc_csu_init> 地址传入 eax，然后压栈   0x00000423 <+35>:    push   eax   0x00000424 <+36>:    push   ecx                              ;ecx、esi 入栈保存   0x00000425 <+37>:    push   esi   0x00000426 <+38>:    push   DWORD PTR [ebx-0x8]              ;调用 main() 函数之前保存返回地址，其实就是保存 main() 函数的入口地址   0x0000042c <+44>:    call   0x3e0 <__libc_start_main@plt>    ;call 指令调用 __libc_start_main 函数   0x00000431 <+49>:    hlt                                     ;hlt 指令使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志。当 RESET 线上有复位信号、CPU 响应非屏蔽终端、CPU 响应可屏蔽终端 3 种情况之一时，CPU 脱离暂停状态，执行下一条指令   0x00000432 <+50>:    mov    ebx,DWORD PTR [esp]              ;esp 强制转换为双字数据后保存到 ebx   0x00000435 <+53>:    ret                                     ;返回，相当于 pop eip;   0x00000436 <+54>:    xchg   ax,ax                            ;交换 ax 和 ax 的数据，相当于 nop   0x00000438 <+56>:    xchg   ax,ax   0x0000043a <+58>:    xchg   ax,ax   0x0000043c <+60>:    xchg   ax,ax   0x0000043e <+62>:    xchg   ax,axEnd of assembler dump.
```

### 函数调用约定

函数调用约定是对函数调用时如何传递参数的一种约定。调用函数前要先把参数压入栈然后再传递给函数。

一个调用约定大概有如下的内容：

- 函数参数的传递顺序和方式
- 栈的维护方式
- 名字修饰的策略

主要的函数调用约定如下，其中 cdecl 是 C 语言默认的调用约定：

| 调用约定 | 出栈方     | 参数传递                                                     | 名字修饰                        |
| :------- | :--------- | :----------------------------------------------------------- | :------------------------------ |
| cdecl    | 函数调用方 | 从右到左的顺序压参数入栈                                     | 下划线＋函数名                  |
| stdcall  | 函数本身   | 从右到左的顺序压参数入栈                                     | 下划线＋函数名＋@＋参数的字节数 |
| fastcall | 函数本身   | 都两个 DWORD（4 字节）类型或者占更少字节的参数被放入寄存器，其他剩下的参数按从右到左的顺序压入栈 | @＋函数名＋@＋参数的字节数      |

除了参数的传递之外，函数与调用方还可以通过返回值进行交互。当返回值不大于 4 字节时，返回值存储在 eax 寄存器中，当返回值在 5~8 字节时，采用 eax 和 edx 结合的形式返回，其中 eax 存储低 4 字节， edx 存储高 4 字节。

## 堆与内存管理

### 堆

![img](https://static.sitestack.cn/projects/CTF-All-In-One/pic/1.5.7_spacelayout.png)

堆是用于存放除了栈里的东西之外所有其他东西的内存区域，有动态内存分配器负责维护。分配器将堆视为一组不同大小的块（block）的集合来维护，每个块就是一个连续的虚拟内存器片（chunk）。当使用 `malloc()` 和 `free()` 时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生内存泄露。

堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

如果每次申请内存时都直接使用系统调用，会严重影响程序的性能。通常情况下，运行库先向操作系统“批发”一块较大的堆空间，然后“零售”给程序使用。当全部“售完”之后或者剩余空间不能满足程序的需求时，再根据情况向操作系统“进货”。

### 进程堆管理

Linux 提供了两种堆空间分配的方式，一个是 `brk()` 系统调用，另一个是 `mmap()` 系统调用。可以使用 `man brk`、`man mmap` 查看。

`brk()` 的声明如下：

```
#include <unistd.h>int brk(void *addr);void *sbrk(intptr_t increment);
```

参数 `*addr` 是进程数据段的结束地址，`brk()` 通过改变该地址来改变数据段的大小，当结束地址向高地址移动，进程内存空间增大，当结束地址向低地址移动，进程内存空间减小。`brk()`调用成功时返回 0，失败时返回 -1。 `sbrk()` 与 `brk()` 类似，但是参数 `increment` 表示增量，即增加或减少的空间大小，调用成功时返回增加后减小前数据段的结束地址，失败时返回 -1。

在上图中我们看到 brk 指示堆结束地址，start_brk 指示堆开始地址。BSS segment 和 heap 之间有一段 Random brk offset，这是由于 ASLR 的作用，如果关闭了 ASLR，则 Random brk offset 为 0，堆结束地址和数据段开始地址重合。

例子：[源码](https://www.bookstack.cn/read/CTF-All-In-One/$src-others-1.5.7_memory-brk.c)

```
#include <stdio.h>#include <unistd.h>void main() {        void *curr_brk, *tmp_brk, *pre_brk;        printf("当前进程 PID：%d\n", getpid());        tmp_brk = curr_brk = sbrk(0);        printf("初始化后的结束地址：%p\n", curr_brk);        getchar();        brk(curr_brk+4096);        curr_brk = sbrk(0);        printf("brk 之后的结束地址：%p\n", curr_brk);        getchar();        pre_brk = sbrk(4096);        curr_brk = sbrk(0);        printf("sbrk 返回值（即之前的结束地址）：%p\n", pre_brk);        printf("sbrk 之后的结束地址：%p\n", curr_brk);        getchar();        brk(tmp_brk);        curr_brk = sbrk(0);        printf("恢复到初始化时的结束地址：%p\n", curr_brk);        getchar();}
```

开启两个终端，一个用于执行程序，另一个用于观察内存地址。首先我们看关闭了 ASLR 的情况。第一步初始化：

```
# echo 0 > /proc/sys/kernel/randomize_va_space
$ ./a.out当前进程 PID：27759初始化后的结束地址：0x56579000
# cat /proc/27759/maps...56557000-56558000 rw-p 00001000 08:01 28587506                           /home/a.out56558000-56579000 rw-p 00000000 00:00 0                                  [heap]...
```

数据段结束地址和堆开始地址同为 `0x56558000`，堆结束地址为 `0x56579000`。

第二步使用 `brk()` 增加堆空间：

```
$ ./a.out当前进程 PID：27759初始化后的结束地址：0x56579000brk 之后的结束地址：0x5657a000
# cat /proc/27759/maps...56557000-56558000 rw-p 00001000 08:01 28587506                           /home/a.out56558000-5657a000 rw-p 00000000 00:00 0                                  [heap]...
```

堆开始地址不变，结束地址增加为 `0x5657a000`。

第三步使用 `sbrk()` 增加堆空间：

```
$ ./a.out当前进程 PID：27759初始化后的结束地址：0x56579000brk 之后的结束地址：0x5657a000sbrk 返回值（即之前的结束地址）：0x5657a000sbrk 之后的结束地址：0x5657b000
# cat /proc/27759/maps...56557000-56558000 rw-p 00001000 08:01 28587506                           /home/a.out56558000-5657b000 rw-p 00000000 00:00 0                                  [heap]...
```

第四步减小堆空间：

```
$ ./a.out当前进程 PID：27759初始化后的结束地址：0x56579000brk 之后的结束地址：0x5657a000sbrk 返回值（即之前的结束地址）：0x5657a000sbrk 之后的结束地址：0x5657b000恢复到初始化时的结束地址：0x56579000
# cat /proc/27759/maps...56557000-56558000 rw-p 00001000 08:01 28587506                           /home/a.out56558000-56579000 rw-p 00000000 00:00 0                                  [heap]...
```

再来看一下开启了 ASLR 的情况：

```
# echo 2 > /proc/sys/kernel/randomize_va_space
$ ./a.out当前进程 PID：28025初始化后的结束地址：0x578ad000
# cat /proc/28025/maps...5663f000-56640000 rw-p 00001000 08:01 28587506                           /home/a.out5788c000-578ad000 rw-p 00000000 00:00 0                                  [heap]...
```

可以看到这时数据段的结束地址 `0x56640000` 不等于堆的开始地址 `0x5788c000`。

`mmap()` 的声明如下：

```
#include <sys/mman.h>void *mmap(void *addr, size_t len, int prot, int flags,    int fildes, off_t off);
```

`mmap()` 函数用于创建新的虚拟内存区域，并将对象映射到这些区域中，当它不将地址空间映射到某个文件时，我们称这块空间为匿名（Anonymous）空间，匿名空间可以用来作为堆空间。`mmap()` 函数要求内核创建一个从地址 `addr` 开始的新虚拟内存区域，并将文件描述符 `fildes` 指定的对象的一个连续的片（chunk）映射到这个新区域。连续的对象片大小为 `len` 字节，从距文件开始处偏移量为 `off` 字节的地方开始。`prot` 描述虚拟内存区域的访问权限位，`flags` 描述被映射对象类型的位组成。

`munmap()` 则用于删除虚拟内存区域：

```
#include <sys/mman.h>int munmap(void *addr, size_t len);
```

例子：[源码](https://www.bookstack.cn/read/CTF-All-In-One/$src-others-1.5.7_memory-mmap.c)

```
#include <stdio.h>#include <sys/mman.h>#include <unistd.h>void main() {    void *curr_brk;    printf("当前进程 PID：%d\n", getpid());    printf("初始化后\n");    getchar();    char *addr;    addr = mmap(NULL, (size_t)4096, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);    printf("mmap 完成\n");    getchar();    munmap(addr, (size_t)4096);    printf("munmap 完成\n");    getchar();}
```

第一步初始化：

```
$ ./a.out当前进程 PID：28652初始化后
# cat /proc/28652/maps...f76b2000-f76b5000 rw-p 00000000 00:00 0f76ef000-f76f1000 rw-p 00000000 00:00 0...
```

第二步 mmap：

```
]$ ./a.out当前进程 PID：28652初始化后mmap 完成
# cat /proc/28652/maps...f76b2000-f76b5000 rw-p 00000000 00:00 0f76ee000-f76f1000 rw-p 00000000 00:00 0...
```

第三步 munmap：

```
$ ./a.out当前进程 PID：28652初始化后mmap 完成munmap 完成
# cat /proc/28652/maps...f76b2000-f76b5000 rw-p 00000000 00:00 0f76ef000-f76f1000 rw-p 00000000 00:00 0...
```

可以看到第二行第一列地址从 `f76ef000`->`f76ee000`->`f76ef000` 变化。`0xf76ee000-0xf76ef000=0x1000=4096`。

通常情况下，我们不会直接使用 `brk()` 和 `mmap()` 来分配堆空间，C 标准库提供了一个叫做 `malloc` 的分配器，程序通过调用 `malloc()` 函数来从堆中分配块，声明如下：

```
#include <stdlib.h>void *malloc(size_t size);void free(void *ptr);void *calloc(size_t nmemb, size_t size);void *realloc(void *ptr, size_t size);
```

示例：

```
#include<stdio.h>#include<malloc.h>void foo(int n) {    int *p;    p = (int *)malloc(n * sizeof(int));    for (int i=0; i<n; i++) {        p[i] = i;        printf("%d ", p[i]);    }    printf("\n");    free(p);}void main() {    int n;    scanf("%d", &n);    foo(n);}
```

运行结果：

```
$ ./malloc40 1 2 3$ ./malloc80 1 2 3 4 5 6 7$ ./malloc160 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

使用 gdb 查看反汇编代码：

```
gdb-peda$ disassemble fooDump of assembler code for function foo:   0x0000066d <+0>:     push   ebp   0x0000066e <+1>:     mov    ebp,esp   0x00000670 <+3>:     push   ebx   0x00000671 <+4>:     sub    esp,0x14   0x00000674 <+7>:     call   0x570 <__x86.get_pc_thunk.bx>   0x00000679 <+12>:    add    ebx,0x1987   0x0000067f <+18>:    mov    eax,DWORD PTR [ebp+0x8]   0x00000682 <+21>:    shl    eax,0x2   0x00000685 <+24>:    sub    esp,0xc   0x00000688 <+27>:    push   eax   0x00000689 <+28>:    call   0x4e0 <malloc@plt>   0x0000068e <+33>:    add    esp,0x10   0x00000691 <+36>:    mov    DWORD PTR [ebp-0xc],eax   0x00000694 <+39>:    mov    DWORD PTR [ebp-0x10],0x0   0x0000069b <+46>:    jmp    0x6d9 <foo+108>   0x0000069d <+48>:    mov    eax,DWORD PTR [ebp-0x10]   0x000006a0 <+51>:    lea    edx,[eax*4+0x0]   0x000006a7 <+58>:    mov    eax,DWORD PTR [ebp-0xc]   0x000006aa <+61>:    add    edx,eax   0x000006ac <+63>:    mov    eax,DWORD PTR [ebp-0x10]   0x000006af <+66>:    mov    DWORD PTR [edx],eax   0x000006b1 <+68>:    mov    eax,DWORD PTR [ebp-0x10]   0x000006b4 <+71>:    lea    edx,[eax*4+0x0]   0x000006bb <+78>:    mov    eax,DWORD PTR [ebp-0xc]   0x000006be <+81>:    add    eax,edx   0x000006c0 <+83>:    mov    eax,DWORD PTR [eax]   0x000006c2 <+85>:    sub    esp,0x8   0x000006c5 <+88>:    push   eax   0x000006c6 <+89>:    lea    eax,[ebx-0x17e0]   0x000006cc <+95>:    push   eax   0x000006cd <+96>:    call   0x4b0 <printf@plt>   0x000006d2 <+101>:   add    esp,0x10   0x000006d5 <+104>:   add    DWORD PTR [ebp-0x10],0x1   0x000006d9 <+108>:   mov    eax,DWORD PTR [ebp-0x10]   0x000006dc <+111>:   cmp    eax,DWORD PTR [ebp+0x8]   0x000006df <+114>:   jl     0x69d <foo+48>   0x000006e1 <+116>:   sub    esp,0xc   0x000006e4 <+119>:   push   0xa   0x000006e6 <+121>:   call   0x500 <putchar@plt>   0x000006eb <+126>:   add    esp,0x10   0x000006ee <+129>:   sub    esp,0xc   0x000006f1 <+132>:   push   DWORD PTR [ebp-0xc]   0x000006f4 <+135>:   call   0x4c0 <free@plt>   0x000006f9 <+140>:   add    esp,0x10   0x000006fc <+143>:   nop   0x000006fd <+144>:   mov    ebx,DWORD PTR [ebp-0x4]   0x00000700 <+147>:   leave     0x00000701 <+148>:   retEnd of assembler dump.
```

关于 glibc 中的 malloc 实现是一个很重要的话题，我们会在后面的章节详细介绍。



# glibc malloc

- [glibc](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.8_glibc_malloc.md#glibc)
- [malloc](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.8_glibc_malloc.md#malloc)
- [参考资料](https://www.bookstack.cn/read/CTF-All-In-One/doc-1.5.8_glibc_malloc.md#参考资料)

[下载文件](https://www.bookstack.cn/read/CTF-All-In-One/$src-others-1.5.8_glibc_malloc)

## glibc

glibc 即 GNU C Library，是为 GNU 操作系统开发的一个 C 标准库。glibc 主要由两部分组成，一部分是头文件，位于 `/usr/include`；另一部分是库的二进制文件。二进制文件部分主要是 C 语言标准库，有动态和静态两个版本，动态版本位于 `/lib/libc.so.6`，静态版本位于 `/usr/lib/libc.a`。

这一章中，我们将阅读分析 glibc 的源码，下面先把它下载下来，并切换到我们需要的版本：

```
$ git clone git://sourceware.org/git/glibc.git$ cd glibc$ git checkout --track -b local_glibc-2.23 origin/release/2.23/master
```

下面来编译它，首先修改配置文件 Makeconfig，将 `-Werror` 注释掉，这样可以避免高版本 GCC（v8.1.0） 将警告当做错误处理：

```
$ cat Makeconfig | grep -i werror | grep warn+gccwarn += #-Werror
```

接下来需要打上一个 patch：

```
$ cat regexp.patchdiff --git a/misc/regexp.c b/misc/regexp.cindex 19d76c0..9017bc1 100644--- a/misc/regexp.c+++ b/misc/regexp.c@@ -29,14 +29,17 @@ #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_23)-/* Define the variables used for the interface.  */-char *loc1;-char *loc2;+#include <stdlib.h>    /* Get NULL.  */++/* Define the variables used for the interface.  Avoid .symver on common+   symbol, which just creates a new common symbol, not an alias.  */+char *loc1 = NULL;+char *loc2 = NULL; compat_symbol (libc, loc1, loc1, GLIBC_2_0); compat_symbol (libc, loc2, loc2, GLIBC_2_0); /* Although we do not support the use we define this variable as well.  */-char *locs;+char *locs = NULL; compat_symbol (libc, locs, locs, GLIBC_2_0);$ patch misc/regexp.c regexp.patch
```

然后就可以编译了：

```
$ mkdir build && cd build$ ../configure --prefix=/usr/local/glibc-2.23$ make -j4 && sudo make install
```

如果我们想要在编译程序时指定 libc，可以像这样：

```
$ gcc -L/usr/local/glibc-2.23/lib -Wl,--rpath=/usr/local/glibc-2.23/lib -Wl,-I/usr/local/glibc-2.23/lib/ld-2.23.so test.c$ ldd a.out        linux-vdso.so.1 (0x00007ffcc76b0000)        libc.so.6 => /usr/local/glibc-2.23/lib/libc.so.6 (0x00007f6abd578000)        /usr/local/glibc-2.23/lib/ld-2.23.so => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f6abdb1c000)
```

然后如果希望在调试时指定 libc 的源文件，可以使用 gdb 命令 `directory`，但是这种方法的缺点是不能解析子目录，所以推荐使用下面的命令在启动时加载：

```
gdb `find ~/path/to/glibc/source -type d -printf '-d %p '` ./a.out
```

## malloc.c

下面我们先分析 glibc 2.23 版本的源码，它是 Ubuntu16.04 的默认版本，在 pwn 中也最常见。然后，我们再探讨新版本的 glibc 中所加入的漏洞缓解机制。

## 相关结构

### 堆块结构

- Allocated Chunk
- Free Chunk
- Top Chunk

### Bins 结构

- Fast Bins
- Small Bins
- Large Bins
- Unsorted Bins

### Arena 结构

## 分配函数

```
_int_malloc()
```

## 释放函数

```
_int_free()
```

## 重分配函数

```
_int_realloc()
```

## 参考资料

- [The GNU C Library (glibc)](https://www.gnu.org/software/libc/)
- [glibc manual](https://www.gnu.org/software/libc/manual/)



